# -*- coding: utf-8 -*-
# smart_alpaca_bot.py ‚Äî Smart autotrade: Stocks + Crypto (Alpaca), –±–µ–∑ whitelist
# –ó–∞–≤–∂–¥–∏ —Å–∫–∞–Ω—É—î —ñ –∞–∫—Ü—ñ—ó, —ñ –∫—Ä–∏–ø—Ç—É. –û—Ä–¥–µ—Ä–∏:
# - Stocks: —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Ä–∏–Ω–æ–∫ –≤—ñ–¥–∫—Ä–∏—Ç–∏–π
# - Crypto: –∑–∞–≤–∂–¥–∏ (24/7)
# –†–µ–∂–∏–º–∏: /mode_aggr (15m + –ø—ñ–¥—Ç–≤. 30m), /mode_safe (15m + –ø—ñ–¥—Ç–≤. 30m —ñ 1h)

import os, asyncio, aiohttp, logging, html
from typing import List, Dict, Optional, Tuple
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes

# ================= ENV =================
TG_TOKEN        = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()

ALP_KEY         = (os.getenv("ALPACA_API_KEY") or os.getenv("APCA_API_KEY_ID") or "").strip()
ALP_SECRET      = (os.getenv("ALPACA_API_SECRET") or os.getenv("APCA_API_SECRET_KEY") or "").strip()
ALP_BASE        = (os.getenv("ALPACA_BASE_URL") or "https://paper-api.alpaca.markets").strip()
ALP_DATA        = (os.getenv("ALPACA_DATA_URL") or "https://data.alpaca.markets").strip()

AUTOTRADE_ON    = os.getenv("ALPACA_ENABLE", "0").strip() == "1"
NOTIONAL_USD    = float(os.getenv("ALPACA_NOTIONAL", "25"))  # —Å—É–º–∞ –Ω–∞ —É–≥–æ–¥—É
MAX_STOCKS      = int(os.getenv("ALPACA_MAX_STOCKS", "200")) # –ª—ñ–º—ñ—Ç, —â–æ–±–∏ –Ω–µ –ª–æ–≤–∏—Ç–∏ rate-limit
MAX_CRYPTO      = int(os.getenv("ALPACA_MAX_CRYPTO", "200"))

SCAN_EVERY_SEC  = int(os.getenv("SCAN_EVERY_SEC", "120"))     # –ø–µ—Ä—ñ–æ–¥ –∞–≤—Ç–æ—Å–∫–∞–Ω–∞

# ================= LOGS =================
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
log = logging.getLogger("smart")

# ================= UI ===================
def kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        [
            ["/signals", "/status"],
            ["/mode_aggr", "/mode_safe"],
            ["/autotrade_on", "/autotrade_off"]
        ], resize_keyboard=True
    )

# ================= STATE ================
STATE: Dict[int, Dict[str, object]] = {}
def default_state() -> Dict[str, object]:
    return {
        "mode": "safe",           # safe | aggr
        "autotrade": AUTOTRADE_ON,
        "alp_notional": NOTIONAL_USD,
        "last_scan_txt": "",
    }

# ================= HELPERS ==============
def now_utc() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")

def fmt_usd(x: float) -> str:
    s = "-" if x < 0 else ""
    x = abs(x)
    return f"{s}${x:,.2f}"

# =============== HTTP ===================
def alp_headers():
    return {"APCA-API-KEY-ID": ALP_KEY, "APCA-API-SECRET-KEY": ALP_SECRET, "Content-Type":"application/json"}

async def http_get(url: str, params: dict=None, headers: dict=None, timeout: int=30):
    async with aiohttp.ClientSession() as s:
        async with s.get(url, params=params, headers=headers, timeout=timeout) as r:
            if r.status >= 400:
                raise RuntimeError(f"GET {url} {r.status}: {await r.text()}")
            return await r.json()

async def http_post(url: str, payload: dict=None, headers: dict=None, timeout: int=30):
    async with aiohttp.ClientSession() as s:
        async with s.post(url, json=payload, headers=headers, timeout=timeout) as r:
            if r.status >= 400:
                raise RuntimeError(f"POST {url} {r.status}: {await r.text()}")
            return await r.json()

# =============== ALPACA CORE ===============
async def alp_clock() -> dict:
    return await http_get(f"{ALP_BASE}/v2/clock", headers=alp_headers())

async def alp_account() -> dict:
    return await http_get(f"{ALP_BASE}/v2/account", headers=alp_headers())

async def alp_assets(asset_class: str) -> List[dict]:
    # asset_class: "us_equity" –∞–±–æ "crypto"
    data = await http_get(f"{ALP_BASE}/v2/assets", params={"asset_class": asset_class, "status":"active"}, headers=alp_headers())
    # –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä—É—î–º–æ tradable
    return [a for a in data if a.get("tradable")]

# Bars
async def bars_stocks(symbol: str, tf: str, limit: int=300):
    url = f"{ALP_DATA}/v2/stocks/bars"
    js = await http_get(url, params={"symbols": symbol, "timeframe": tf, "limit": str(limit), "adjustment":"split"}, headers=alp_headers())
    series = (js.get("bars") or {}).get(symbol, [])
    O=H=L=C=V=[],[],[],[],[]
    O,H,L,C,V = [],[],[],[],[]
    for b in series[-limit:]:
        try:
            O.append(float(b["o"])); H.append(float(b["h"])); L.append(float(b["l"]))
            C.append(float(b["c"])); V.append(float(b["v"]))
        except: pass
    return O,H,L,C,V

async def bars_crypto(symbol: str, tf: str, limit: int=300):
    # symbol: BTCUSD / ETHUSD / SOLUSD (–±–µ–∑ '/')
    # v1beta3 crypto US
    base = "https://data.alpaca.markets/v1beta3"
    url = f"{base}/crypto/us/bars"
    js = await http_get(url, params={"symbols": symbol, "timeframe": tf, "limit": str(limit)}, headers=alp_headers())
    series = (js.get("bars") or {}).get(symbol, [])
    O,H,L,C,V = [],[],[],[],[]
    for b in series[-limit:]:
        try:
            O.append(float(b["o"])); H.append(float(b["h"])); L.append(float(b["l"]))
            C.append(float(b["c"])); V.append(float(b["v"]))
        except: pass
    return O,H,L,C,V

# =============== INDICATORS ===============
def ema(xs: List[float], p: int) -> List[float]:
    if not xs: return []
    k = 2/(p+1); out=[xs[0]]
    for x in xs[1:]: out.append(out[-1] + k*(x - out[-1]))
    return out

def rsi(xs: List[float], p: int = 14) -> List[float]:
    if len(xs) < p+1: return []
    gains, losses = [], []
    for i in range(1, len(xs)):
        d = xs[i]-xs[i-1]
        gains.append(max(0,d)); losses.append(max(0,-d))
    ag = sum(gains[:p])/p; al = sum(losses[:p])/p
    out=[0.0]*p; out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    for i in range(p, len(gains)):
        ag=(ag*(p-1)+gains[i])/p; al=(al*(p-1)+losses[i])/p
        out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    return out

def macd(xs: List[float], fast=12, slow=26, signal=9) -> Tuple[List[float], List[float]]:
    if len(xs) < slow+signal: return [], []
    ef, es = ema(xs, fast), ema(xs, slow)
    m=[a-b for a,b in zip(ef[-len(es):], es)]; s=ema(m, signal)
    L=min(len(m),len(s)); return m[-L:], s[-L:]

def atr_val(h: List[float], l: List[float], c: List[float], n: int=14) -> float:
    if len(c) < n+1: return 0.0
    trs=[]
    for i in range(1,len(c)):
        trs.append(max(h[i]-l[i], abs(h[i]-c[i-1]), abs(l[i]-c[i-1])))
    if len(trs)<n: return 0.0
    return sum(trs[-n:])/n

# =============== SIGNAL LOGIC ===============
def decide_side_15m(c15: List[float], h15: List[float], l15: List[float], min_adx: float) -> Optional[str]:
    if len(c15) < 60: return None
    e20 = ema(c15, 20)[-1]; e50 = ema(c15, 50)[-1]
    rr = rsi(c15,14); rlast = rr[-1] if rr else 50.0
    m,s = macd(c15); macd_up = (m and s and m[-1] > s[-1])
    # –ø—Ä–æ—Å—Ç–∏–π ADX-–ø—Ä–æ–∫—Å—ñ: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω –æ—Å—Ç–∞–Ω–Ω—ñ—Ö —Å–≤—ñ—á–æ–∫
    adx_proxy = abs(c15[-1]-c15[-2]) / max(1e-9, c15[-2]) * 100 * 10
    # LONG
    if c15[-1] > e20 > e50 and rlast > 52 and macd_up and adx_proxy >= min_adx:
        return "LONG"
    # SHORT
    if c15[-1] < e20 < e50 and rlast < 48 and not macd_up and adx_proxy >= min_adx:
        return "SHORT"
    return None

def confirm_trend(c: List[float], side: str) -> bool:
    if len(c) < 60: return False
    e20 = ema(c,20)[-1]; e50 = ema(c,50)[-1]
    if side == "LONG":  return e20 > e50
    if side == "SHORT": return e20 < e50
    return False

def sl_tp_from_atr(side: str, px: float, h: List[float], l: List[float], c: List[float], sl_k: float, rr_k: float):
    a = atr_val(h,l,c,14)
    if a<=0: a = max(1e-9, abs(c[-1]-c[-2]))
    if side=="LONG":
        sl = px - sl_k*a; risk = px - sl; tp = px + rr_k*risk
    else:
        sl = px + sl_k*a; risk = sl - px; tp = px - rr_k*risk
    return sl, tp

# —Ä–µ–∂–∏–º ‚Üí –ø–æ—Ä–æ–≥–∏
MODE_PARAMS = {
    "aggr": {"min_adx": 10, "sl_k": 1.2, "rr_k": 2.0},
    "safe": {"min_adx": 12, "sl_k": 1.3, "rr_k": 2.2},
}

# =============== SCAN BOTH ===============
async def scan_all(st: Dict[str,object]) -> Tuple[str, List[Dict], List[Dict]]:
    """–ü–æ–≤–µ—Ä—Ç–∞—î (report_text, picks_stocks, picks_crypto)."""
    mode = st.get("mode","safe")
    mp = MODE_PARAMS["aggr" if mode=="aggr" else "safe"]
    min_adx = mp["min_adx"]; sl_k=mp["sl_k"]; rr_k=mp["rr_k"]

    # 1) assets
    try:
        stocks = await alp_assets("us_equity")
        crypto = await alp_assets("crypto")
    except Exception as e:
        return f"‚ùå assets error: {e}", [], []

    stocks = stocks[:MAX_STOCKS]
    crypto = crypto[:MAX_CRYPTO]

    # 2) market clock
    market_open = False
    try:
        clk = await alp_clock()
        market_open = bool(clk.get("is_open", False))
    except Exception as e:
        log.warning("clock error: %s", e)

    picks_stocks=[]; picks_crypto=[]
    bad_s, bad_c = 0, 0

    # 3) scan stocks
    for a in stocks:
        sym = a.get("symbol","")
        try:
            o15,h15,l15,c15,_ = await bars_stocks(sym, "15Min", 300)
            o30,h30,l30,c30,_ = await bars_stocks(sym, "30Min", 300)
            o60,h60,l60,c60,_ = await bars_stocks(sym, "1Hour", 300)
            if not (c15 and c30 and c60): 
                bad_s += 1; continue
            side = decide_side_15m(c15,h15,l15,min_adx)
            if not side: 
                continue
            if not confirm_trend(c30, side): 
                continue
            if mode=="safe" and not confirm_trend(c60, side):
                continue
            px = float(c15[-1])
            sl,tp = sl_tp_from_atr(side, px, h15,l15,c15, sl_k, rr_k)
            picks_stocks.append({"symbol": sym, "side": side, "px": px, "sl": sl, "tp": tp})
        except Exception:
            bad_s += 1

    # 4) scan crypto
    for a in crypto:
        sym = a.get("symbol","")
        # –£ Alpaca crypto —Å–∏–º–≤–æ–ª–∏ –≤–∏–≥–ª—è–¥—É BTCUSD
        try:
            o15,h15,l15,c15,_ = await bars_crypto(sym, "15Min", 300)
            o30,h30,l30,c30,_ = await bars_crypto(sym, "30Min", 300)
            o60,h60,l60,c60,_ = await bars_crypto(sym, "1Hour", 300)
            if not (c15 and c30 and c60):
                bad_c += 1; continue
            side = decide_side_15m(c15,h15,l15,min_adx)
            if not side: 
                continue
            if not confirm_trend(c30, side): 
                continue
            if mode=="safe" and not confirm_trend(c60, side):
                continue
            px = float(c15[-1])
            sl,tp = sl_tp_from_atr(side, px, h15,l15,c15, sl_k, rr_k)
            picks_crypto.append({"symbol": sym, "side": side, "px": px, "sl": sl, "tp": tp})
        except Exception:
            bad_c += 1

    # 5) report
    def fmt_pick(p):
        return f"‚Ä¢ {p['symbol']} ‚Äî {p['side']} @ `{p['px']:.4f}` | SL:`{p['sl']:.4f}` TP:`{p['tp']:.4f}`"
    parts=[f"üïí UTC {now_utc()}", f"Market open: {'YES' if market_open else 'NO'}", f"Mode: {mode}"]
    parts.append(f"\nüìà Stocks (scanned {len(stocks)}, bad {bad_s}) ‚Äî found {len(picks_stocks)}")
    parts += [fmt_pick(p) for p in picks_stocks[:10]]
    parts.append(f"\nü™ô Crypto (scanned {len(crypto)}, bad {bad_c}) ‚Äî found {len(picks_crypto)}")
    parts += [fmt_pick(p) for p in picks_crypto[:10]]
    return "\n".join(parts), picks_stocks, picks_crypto

# =============== PLACE ORDERS ===============
async def place_orders(st: Dict[str,object], ctx: ContextTypes.DEFAULT_TYPE, chat_id: int,
                       market_open: bool, picks_stocks: List[Dict], picks_crypto: List[Dict]):
    if not st.get("autotrade", False):
        return

    # Stocks: —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ market_open
    async def post_order(payload):
        try:
            js = await http_post(f"{ALP_BASE}/v2/orders", payload, headers=alp_headers())
            return js.get("id","?")
        except Exception as e:
            return f"ERR: {e}"

    notional = float(st.get("alp_notional", NOTIONAL_USD))

    if market_open:
        placed=[]
        for p in picks_stocks[:5]:
            payload = {
                "symbol": p["symbol"], "side": "buy" if p["side"]=="LONG" else "sell",
                "type":"market", "time_in_force":"day",
                "notional": round(notional,2),
                "order_class":"bracket",
                "take_profit": {"limit_price": round(p["tp"], 4)},
                "stop_loss":  {"stop_price": round(p["sl"], 4)}
            }
            oid = await post_order(payload)
            placed.append(f"‚úÖ STOCK {p['symbol']} {p['side']} ~{fmt_usd(notional)} id `{oid}`")
        if placed:
            await ctx.bot.send_message(chat_id, "\n".join(placed))

    # Crypto: –º–æ–∂–Ω–∞ –∑–∞–≤–∂–¥–∏ (bracket –º–æ–∂–µ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞—Ç–∏—Å—å –¥–ª—è crypto ‚Üí —Å—Ç–∞–≤–∏–º–æ –ø—Ä–æ—Å—Ç–∏–π market)
    placed=[]
    for p in picks_crypto[:5]:
        payload = {
            "symbol": p["symbol"], "side": "buy" if p["side"]=="LONG" else "sell",
            "type":"market", "time_in_force":"gtc",
            "notional": round(notional,2)
        }
        oid = await post_order(payload)
        placed.append(f"‚úÖ CRYPTO {p['symbol']} {p['side']} ~{fmt_usd(notional)} id `{oid}`")
    if placed:
        await ctx.bot.send_message(chat_id, "\n".join(placed))

# =============== TELEGRAM HANDLERS ===============
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    STATE.setdefault(u.effective_chat.id, default_state())
    await u.message.reply_text("ü§ñ Smart Alpaca Bot ‚Äî –≥–æ—Ç–æ–≤–∏–π. –ù–∞—Ç–∏—Å–∫–∞–π /signals –∞–±–æ –≤–º–∏–∫–∞–π –∞–≤—Ç–æ—Ç—Ä–µ–π–¥.",
                              reply_markup=kb())

async def mode_aggr_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["mode"]="aggr"
    await u.message.reply_text("‚úÖ Mode: AGGRESSIVE (15m –≤—Ö—ñ–¥ + –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m).")

async def mode_safe_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["mode"]="safe"
    await u.message.reply_text("‚úÖ Mode: SAFE (15m –≤—Ö—ñ–¥ + –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m —Ç–∞ 1h).")

async def autotrade_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"]=True
    await u.message.reply_text("‚úÖ Autotrade: ON")

async def autotrade_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"]=False
    await u.message.reply_text("‚è∏ Autotrade: OFF")

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    try:
        acc = await alp_account()
        clk = await alp_clock()
        txt = (
            f"üíº Alpaca: status={acc.get('status','?')}, equity={fmt_usd(float(acc.get('equity',0)))}\n"
            f"cash={fmt_usd(float(acc.get('cash',0)))}, buying_power={fmt_usd(float(acc.get('buying_power',0)))}\n"
            f"üïí Market open: {'YES' if clk.get('is_open') else 'NO'}\n"
            f"Mode={st.get('mode')} ¬∑ Autotrade={'ON' if st.get('autotrade') else 'OFF'} ¬∑ Notional={fmt_usd(st.get('alp_notional',NOTIONAL_USD))}\n"
            f"UTC {now_utc()}"
        )
    except Exception as e:
        txt = f"‚ùå status error: {e}"
    await u.message.reply_text(txt)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    rep, picks_s, picks_c = await scan_all(st)
    st["last_scan_txt"] = rep
    # market_open –¥–ª—è –æ—Ä–¥–µ—Ä—ñ–≤ –∞–∫—Ü—ñ–π
    market_open=False
    try:
        clk = await alp_clock(); market_open = bool(clk.get("is_open", False))
    except: pass
    # –ù–∞–¥—Å–∏–ª–∞—î–º–æ –∑–≤—ñ—Ç
    for chunk in [rep[i:i+3500] for i in range(0, len(rep), 3500)]:
        await u.message.reply_text(chunk, parse_mode=ParseMode.MARKDOWN)
    # –Ø–∫—â–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ‚Äî —Å—Ç–∞–≤–∏–º–æ –æ—Ä–¥–µ—Ä–∏ –∑–∞ –ø—Ä–∞–≤–∏–ª–∞–º–∏
    if st.get("autotrade", False):
        await place_orders(st, c, u.effective_chat.id, market_open, picks_s, picks_c)

# –ê–≤—Ç–æ—Å–∫–∞–Ω —É —Ñ–æ–Ω—ñ (–∑–∞ –±–∞–∂–∞–Ω–Ω—è–º)
async def periodic_scan(ctx: ContextTypes.DEFAULT_TYPE):
    for chat_id, st in list(STATE.items()):
        try:
            rep, picks_s, picks_c = await scan_all(st)
            STATE[chat_id]["last_scan_txt"]=rep
            # –º–æ–∂–Ω–∞ –Ω–µ —Å–ø–∞–º–∏—Ç–∏ –∫–æ–∂–Ω–æ–≥–æ —Ä–∞–∑—É ‚Äî –∞–ª–µ —è–∫—â–æ —Ö–æ—á–µ—à, —Ä–æ–∑–∫–æ–º–µ–Ω—Ç—É–π:
            # await ctx.bot.send_message(chat_id, "‚è± –ê–≤—Ç–æ—Å–∫–∞–Ω –æ–Ω–æ–≤–ª–µ–Ω–æ.")
            if st.get("autotrade", False):
                clk = await alp_clock(); m_open = bool(clk.get("is_open", False))
                await place_orders(st, ctx, chat_id, m_open, picks_s, picks_c)
        except Exception as e:
            log.error("periodic scan error: %s", e)

# =============== MAIN ===================
def main():
    if not (TG_TOKEN and ALP_KEY and ALP_SECRET):
        raise SystemExit("Set TELEGRAM_BOT_TOKEN, ALPACA_API_KEY, ALPACA_API_SECRET")
    app = Application.builder().token(TG_TOKEN).build()
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("signals", signals_cmd))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(CommandHandler("mode_aggr", mode_aggr_cmd))
    app.add_handler(CommandHandler("mode_safe", mode_safe_cmd))
    app.add_handler(CommandHandler("autotrade_on", autotrade_on_cmd))
    app.add_handler(CommandHandler("autotrade_off", autotrade_off_cmd))
    # –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–∏–π –∞–≤—Ç–æ—Å–∫–∞–Ω
    app.job_queue.run_repeating(periodic_scan, interval=SCAN_EVERY_SEC, first=5)
    app.run_polling()

if __name__ == "__main__":
    main()
