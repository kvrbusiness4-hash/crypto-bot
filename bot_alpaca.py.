# bot.py
import os
import csv
import io
import asyncio
import json
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Any

import aiohttp
from aiohttp import ClientSession, ClientTimeout

from telegram import (
    Update,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    KeyboardButton,
)
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# =========================
# ENV
# =========================

TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()

ALPACA_KEY = os.getenv("ALPACA_API_KEY", "").strip()
ALPACA_SECRET = os.getenv("ALPACA_API_SECRET", "").strip()
ALPACA_BASE_URL = os.getenv("ALPACA_BASE_URL", "https://paper-api.alpaca.markets").rstrip("/")
ALPACA_DATA_URL = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets/v2").rstrip("/")

ALPACA_NOTIONAL = float(os.getenv("ALPACA_NOTIONAL", "50"))  # $ per order
ALPACA_ENABLE = os.getenv("ALPACA_ENABLE", "1") == "1"

ALPACA_MAX_STOCKS = int(os.getenv("ALPACA_MAX_STOCKS", "600"))
ALPACA_MAX_CRYPTO = int(os.getenv("ALPACA_MAX_CRYPTO", "300"))
ALPACA_TIMEOUT = int(os.getenv("ALPACA_TIMEOUT", "10"))
ALPACA_TOP_N = int(os.getenv("ALPACA_TOP_N", "10"))

SIGLOG_PATH = os.getenv("SIGLOG_PATH", "signals_log.csv")
SCAN_EVERY_SEC = int(os.getenv("SCAN_EVERY_SEC", "120"))

# =========================
# STATE (–Ω–∞ —á–∞—Ç)
# =========================

def default_state():
    return {
        "autotrade": False,
        "mode": "default",  # aggressive | scalp | default | swing | safe
        "last_scan_txt": "",
        "last_symbols": [],
    }

STATE: Dict[int, Dict[str, Any]] = {}

# =========================
# –î–æ–ø–æ–º—ñ–∂–Ω—ñ
# =========================

def now_utc_str() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

def fmt_usd(x: float) -> str:
    return "${:,.2f}".format(x)

def reply_keyboard() -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton("/aggressive"), KeyboardButton("/scalp"), KeyboardButton("/default")],
        [KeyboardButton("/swing"), KeyboardButton("/safe"), KeyboardButton("/help")],
        [KeyboardButton("/signals_alpaca")],
        [KeyboardButton("/alp_on"), KeyboardButton("/alp_status"), KeyboardButton("/alp_off")],
    ]
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

async def set_bot_commands(app: Application) -> None:
    try:
        await app.bot.set_my_commands(
            [
                ("start", "–ü–æ–∫–∞–∑–∞—Ç–∏ –º–µ–Ω—é"),
                ("alp_on", "–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥"),
                ("alp_off", "–í–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥"),
                ("alp_status", "–°—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É Alpaca"),
                ("signals_alpaca", "–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Å–∫–∞–Ω/—É–≥–æ–¥–∏ (–∞–∫—Ü—ñ—ó+–∫—Ä–∏–ø—Ç–∞)"),
                ("aggressive", "–ü—Ä–æ—Ñ—ñ–ª—å: aggressive"),
                ("scalp", "–ü—Ä–æ—Ñ—ñ–ª—å: scalp"),
                ("default", "–ü—Ä–æ—Ñ—ñ–ª—å: default"),
                ("swing", "–ü—Ä–æ—Ñ—ñ–ª—å: swing"),
                ("safe", "–ü—Ä–æ—Ñ—ñ–ª—å: safe"),
                ("help", "–î–æ–ø–æ–º–æ–≥–∞"),
            ]
        )
    except Exception:
        pass

# =========================
# Alpaca HTTP
# =========================

def alp_headers() -> Dict[str, str]:
    return {
        "APCA-API-KEY-ID": ALPACA_KEY,
        "APCA-API-SECRET-KEY": ALPACA_SECRET,
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

def session_timeout() -> ClientTimeout:
    return ClientTimeout(total=ALPACA_TIMEOUT)

# Trading endpoints
async def alp_account(session: ClientSession) -> Dict[str, Any]:
    url = f"{ALPACA_BASE_URL}/v2/account"
    async with session.get(url, headers=alp_headers(), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

async def alp_clock(session: ClientSession) -> Dict[str, Any]:
    url = f"{ALPACA_BASE_URL}/v2/clock"
    async with session.get(url, headers=alp_headers(), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

async def alp_assets(session: ClientSession, asset_class: str) -> List[Dict[str, Any]]:
    # asset_class: "us_equity" –∞–±–æ "crypto"
    url = f"{ALPACA_BASE_URL}/v2/assets?status=active&asset_class={asset_class}"
    async with session.get(url, headers=alp_headers(), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

async def alp_place_order(session: ClientSession, symbol: str, notional: float, side: str = "buy") -> Dict[str, Any]:
    url = f"{ALPACA_BASE_URL}/v2/orders"
    payload = {"symbol": symbol, "notional": notional, "side": side, "type": "market", "time_in_force": "day"}
    async with session.post(url, headers=alp_headers(), data=json.dumps(payload), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

# Market data endpoints (snapshots)
async def stocks_snapshots(session: ClientSession, symbols: List[str]) -> Dict[str, Any]:
    # POST /v2/stocks/snapshots  (–±–∞—Ç—á –¥–æ ~500 —Å–∏–º–≤. –Ω–æ—Ä–º)
    url = f"{ALPACA_DATA_URL}/stocks/snapshots"
    payload = {"symbols": ",".join(symbols)}
    async with session.post(url, headers=alp_headers(), data=json.dumps(payload), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

async def crypto_snapshots(session: ClientSession, symbols: List[str]) -> Dict[str, Any]:
    # Crypto ‚Äî —É v1beta3:
    base = ALPACA_DATA_URL.replace("/v2", "")
    url = f"{base}/v1beta3/crypto/us/snapshots"
    payload = {"symbols": ",".join(symbols)}
    async with session.post(url, headers=alp_headers(), data=json.dumps(payload), timeout=session_timeout()) as r:
        r.raise_for_status()
        return await r.json()

# =========================
# –°–∫–∞–Ω—É–≤–∞–Ω–Ω—è/–æ—Ü—ñ–Ω–∫–∞
# =========================

def score_stock(snap: Dict[str, Any]) -> float:
    # –í–∏–∫–æ—Ä–∏—Å—Ç–∞—î–º–æ daily change %, volume, —Å–ø—Ä–µ–¥
    try:
        daily = snap.get("dailyBar") or {}
        last = snap.get("latestTrade") or {}
        prev_c = float(daily.get("c", 0)) or 0.0
        last_p = float(last.get("p", 0)) or 0.0
        vol = float(daily.get("v", 0)) or 0.0

        if prev_c <= 0 or last_p <= 0 or vol <= 0:
            return -1e9

        chg = (last_p - prev_c) / prev_c * 100.0

        q = snap.get("latestQuote") or {}
        bp = float(q.get("bp", 0) or 0.0)
        ap = float(q.get("ap", 0) or 0.0)
        spread = (ap - bp) / ap * 100.0 if ap > 0 and bp > 0 else 99.0

        # –§—ñ–ª—å—Ç—Ä–∏
        if last_p < 1 or spread > 0.5:
            return -1e9

        # –°–∫–æ—Ä–∏–Ω–≥: –∑–º—ñ–Ω–∞ + –ª–æ–≥ –æ–±‚Äô—î–º—É ‚Äì —à—Ç—Ä–∞—Ñ –∑–∞ —Å–ø—Ä–µ–¥
        score = chg + (0.000001 * vol) - (0.5 * spread)
        return score
    except Exception:
        return -1e9

def score_crypto(snap: Dict[str, Any]) -> float:
    try:
        # –î–ª—è crypto snapshot —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —ñ–Ω—à–∞
        latest = snap.get("latestTrade") or {}
        prev = snap.get("minuteBar") or {}
        last_p = float(latest.get("p", 0)) or 0.0
        prev_c = float(prev.get("c", 0)) or 0.0

        q = snap.get("latestQuote") or {}
        bp = float(q.get("bp", 0) or 0.0)
        ap = float(q.get("ap", 0) or 0.0)
        spread = (ap - bp) / ap * 100.0 if ap > 0 and bp > 0 else 0.3  # –∫—Ä–∏–ø—Ç–∞ ‚Äî —à–∏—Ä—à–∏–π —Å–ø—Ä–µ–¥

        if last_p <= 0:
            return -1e9

        chg = 0.0
        if prev_c > 0:
            chg = (last_p - prev_c) / prev_c * 100.0

        if spread > 0.8:
            return -1e9

        # –û–±—Å—è–≥ –º–æ–∂–µ–º–æ –≤–∑—è—Ç–∏ –∑ minuteBar v
        vol = float(prev.get("v", 0)) or 0.0

        score = chg + (0.00001 * vol) - (0.3 * spread)
        return score
    except Exception:
        return -1e9

async def batch(iterable: List[str], n: int) -> List[List[str]]:
    buf = []
    for s in iterable:
        buf.append(s)
        if len(buf) == n:
            yield buf
            buf = []
    if buf:
        yield buf

async def scan_universe(session: ClientSession, st: Dict[str, Any]) -> Tuple[str, List[Tuple[str, float, str]], List[Tuple[str, float, str]]]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î: (–∑–≤—ñ—Ç-—Ç–µ–∫—Å—Ç, TOP –ø–æ –∞–∫—Ü—ñ—è—Ö, TOP –ø–æ –∫—Ä–∏–ø—Ç—ñ)
    """
    # 1) –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∞–∫—Ç–∏–≤–∏ (–∞–∫—Ü—ñ—ó + –∫—Ä–∏–ø—Ç–∞)
    stocks, crypto = [], []

    # –ê–∫—Ü—ñ—ó
    try:
        assets_st = await alp_assets(session, "us_equity")
        # –ª–∏—à–µ tradable + —Å–∏–º–≤–æ–ª –±–µ–∑ –ø—Ä–µ—Ñ—ñ–∫—Å—ñ–≤:
        stocks = [a["symbol"] for a in assets_st if a.get("tradable")]
        if ALPACA_MAX_STOCKS > 0:
            stocks = stocks[:ALPACA_MAX_STOCKS]
    except Exception:
        stocks = []

    # –ö—Ä–∏–ø—Ç–∞ (Alpaca —Å–∏–º–≤–æ–ª–∏ —Ç–∏–ø—É "BTC/USD")
    try:
        assets_cr = await alp_assets(session, "crypto")
        crypto = [a["symbol"] for a in assets_cr if a.get("tradable")]
        if ALPACA_MAX_CRYPTO > 0:
            crypto = crypto[:ALPACA_MAX_CRYPTO]
    except Exception:
        crypto = []

    # 2) –°–Ω—ñ–ø—à–æ—Ç–∏ + —Å–∫–æ—Ä–∏–Ω–≥
    top_stocks: List[Tuple[str, float, str]] = []
    top_crypto: List[Tuple[str, float, str]] = []

    # –ê–∫—Ü—ñ—ó –±–∞—Ç—á–∞–º–∏
    try:
        for sym_batch in [b async for b in batch(stocks, 400)]:
            data = await stocks_snapshots(session, sym_batch)
            snaps = data.get("snapshots", {})
            for sym, snap in snaps.items():
                sc = score_stock(snap or {})
                if sc > -1e9:
                    last = (snap.get("latestTrade") or {}).get("p")
                    top_stocks.append((sym, sc, f"{last}"))
            await asyncio.sleep(0.05)  # –Ω–µ–≤–µ–ª–∏—á–∫–∞ –ø–∞—É–∑–∞
    except Exception:
        pass

    # –ö—Ä–∏–ø—Ç–∞ –±–∞—Ç—á–∞–º–∏
    try:
        for sym_batch in [b async for b in batch(crypto, 400)]:
            data = await crypto_snapshots(session, sym_batch)
            snaps = data.get("snapshots", {})
            for sym, snap in snaps.items():
                sc = score_crypto(snap or {})
                if sc > -1e9:
                    last = (snap.get("latestTrade") or {}).get("p")
                    top_crypto.append((sym.replace("-", "/"), sc, f"{last}"))
            await asyncio.sleep(0.05)
    except Exception:
        pass

    # 3) –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ TOP_N
    top_stocks.sort(key=lambda x: x[1], reverse=True)
    top_crypto.sort(key=lambda x: x[1], reverse=True)

    top_stocks = top_stocks[:ALPACA_TOP_N]
    top_crypto = top_crypto[:ALPACA_TOP_N]

    # 4) –ó–≤—ñ—Ç
    lines = []
    lines.append(f"üìä Scan @ {now_utc_str()}")
    lines.append(f"Stocks scanned: {len(stocks)} | Crypto scanned: {len(crypto)}")
    if top_stocks:
        lines.append("‚Äî Top Stocks:")
        for s, sc, p in top_stocks:
            lines.append(f"  ‚Ä¢ {s}  score={sc:.3f}  price={p}")
    else:
        lines.append("‚Äî Top Stocks: (none)")

    if top_crypto:
        lines.append("‚Äî Top Crypto:")
        for s, sc, p in top_crypto:
            lines.append(f"  ‚Ä¢ {s}  score={sc:.3f}  price={p}")
    else:
        lines.append("‚Äî Top Crypto: (none)")

    return "\n".join(lines), top_stocks, top_crypto

# =========================
# –û—Ä–¥–µ—Ä–∏
# =========================

async def place_top_orders(session: ClientSession, picks: List[Tuple[str, float, str]], st: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    –°—Ç–∞–≤–∏—Ç–∏–º–µ –æ—Ä–¥–µ—Ä–∏ (market, notional=ALPACA_NOTIONAL) –ø–æ —Å–ø–∏—Å–∫—É picks
    """
    res = []
    for sym, _, _ in picks:
        try:
            od = await alp_place_order(session, sym, ALPACA_NOTIONAL, "buy")
            res.append(od)
            await asyncio.sleep(0.05)
        except Exception as e:
            res.append({"symbol": sym, "error": str(e)})
    return res

# =========================
# –õ–æ–≥–∏ —Å–∏–≥–Ω–∞–ª—ñ–≤ —É CSV
# =========================

def write_siglog(text: str) -> None:
    try:
        with open(SIGLOG_PATH, "a", encoding="utf-8") as f:
            f.write(text.replace("\r", "") + "\n")
    except Exception:
        pass

# =========================
# Handlers
# =========================

async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    st = STATE.setdefault(chat_id, default_state())

    # –ü—Ä–∏–º—É—Å–æ–≤–æ –ø—Ä–∏–±–∏—Ä–∞—î–º–æ —Å—Ç–∞—Ä—É –∫–ª–∞–≤—ñ–∞—Ç—É—Ä—É —ñ —Å—Ç–∞–≤–∏–º–æ –Ω–æ–≤—É
    try:
        await update.message.reply_text("–û–Ω–æ–≤–ª—é—é –º–µ–Ω—é‚Ä¶", reply_markup=ReplyKeyboardRemove())
    except Exception:
        pass

    await update.message.reply_text(
        "üëã –ì–æ—Ç–æ–≤–æ. –ë–æ—Ç —Å–∫–∞–Ω—É—î –∞–∫—Ü—ñ—ó —Ç–∞ –∫—Ä–∏–ø—Ç—É (—ñ –º–æ–∂–µ –∞–≤—Ç–æ—Ç–æ—Ä–≥—É–≤–∞—Ç–∏ –≤ Alpaca).\n\n"
        "‚Ä¢ /alp_on ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ¬∑ /alp_status ‚Äî —Å—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É\n"
        "‚Ä¢ /signals_alpaca ‚Äî –∑–Ω–∞–π—Ç–∏ –Ω–∞–π–∫—Ä–∞—â—ñ –π (—è–∫—â–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ON) –∫—É–ø–∏—Ç–∏\n\n"
        "–ü—Ä–æ—Ñ—ñ–ª—ñ: /aggressive /scalp /default /swing /safe",
        reply_markup=reply_keyboard(),
    )

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ö–æ–º–∞–Ω–¥–∏:\n"
        "/start ‚Äî –º–µ–Ω—é\n"
        "/alp_on ¬∑ /alp_off ‚Äî –∞–≤—Ç–æ—É–≥–æ–¥–∏ ON/OFF\n"
        "/alp_status ‚Äî —Å—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É Alpaca\n"
        "/signals_alpaca ‚Äî —Å–∫–∞–Ω/—É–≥–æ–¥–∏ (–∞–∫—Ü—ñ—ó+–∫—Ä–∏–ø—Ç–∞)\n"
        "–ü—Ä–æ—Ñ—ñ–ª—ñ —Ä–∏–∑–∏–∫—É: /aggressive /scalp /default /swing /safe"
    )

async def alp_on_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(update.effective_chat.id, default_state())
    st["autotrade"] = True
    await update.message.reply_text("‚úÖ Alpaca AUTOTRADE: ON")

async def alp_off_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(update.effective_chat.id, default_state())
    st["autotrade"] = False
    await update.message.reply_text("üü® Alpaca AUTOTRADE: OFF")

async def alp_status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(update.effective_chat.id, default_state())
    try:
        async with aiohttp.ClientSession() as sess:
            acc = await alp_account(sess)
        txt = (
            f"üíº Alpaca: status={acc.get('status','?')}\n"
            f"‚Ä¢ cash={fmt_usd(float(acc.get('cash',0)))} ¬∑ "
            f"buying_power={fmt_usd(float(acc.get('buying_power',0))} ) ¬∑ "
            f"equity={fmt_usd(float(acc.get('equity',0)))}"
        )
        await update.message.reply_text(txt)
    except Exception as e:
        await update.message.reply_text(f"‚ùå Alpaca error: {e}")

async def set_profile(update: Update, context: ContextTypes.DEFAULT_TYPE, name: str):
    st = STATE.setdefault(update.effective_chat.id, default_state())
    st["mode"] = name
    await update.message.reply_text(f"‚òëÔ∏è Mode: {name.upper()}", reply_markup=reply_keyboard())

async def aggressive_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE): await set_profile(u, c, "aggressive")
async def scalp_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE): await set_profile(u, c, "scalp")
async def default_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE): await set_profile(u, c, "default")
async def swing_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE): await set_profile(u, c, "swing")
async def safe_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE): await set_profile(u, c, "safe")

async def signals_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    st = STATE.setdefault(chat_id, default_state())
    await update.message.reply_text("‚è≥ –°–∫–∞–Ω—É—é –∞–∫—Ü—ñ—ó+–∫—Ä–∏–ø—Ç—É‚Ä¶")

    try:
        async with aiohttp.ClientSession() as sess:
            rep, picks_s, picks_c = await scan_universe(sess, st)

            # —Ñ–æ—Ä–º—É—î–º–æ —Ç–µ–∫—Å—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É —á–∞—Å—Ç–∏–Ω–∞–º–∏
            st["last_scan_txt"] = rep
            for chunk in [rep[i:i+3500] for i in range(0, len(rep), 3500)]:
                await update.message.reply_text(chunk)

            write_siglog(rep)

            if st.get("autotrade"):
                # –∫–æ–º–±—ñ–Ω—É—î–º–æ –Ω–∞–π–∫—Ä–∞—â—ñ ‚Äî –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: –æ–±–∏–¥–≤–∞ –Ω–∞–±–æ—Ä–∏
                merged = []
                if picks_s: merged.extend(picks_s[: max(1, len(picks_s)//2)])
                if picks_c: merged.extend(picks_c[: max(1, len(picks_c)//2)])

                if not merged:
                    await update.message.reply_text("‚ÑπÔ∏è –ù–µ–º–∞—î –ø—ñ–¥—Ö–æ–¥—è—â–∏—Ö —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ –¥–ª—è —É–≥–æ–¥.")
                else:
                    await update.message.reply_text("üõí –°—Ç–∞–≤–ª—é —Ä–∏–Ω–∫–æ–≤—ñ –æ—Ä–¥–µ—Ä–∏ (notional)‚Ä¶")
                    placed = await place_top_orders(sess, merged, st)
                    # –ø—ñ–¥—Å—É–º–æ–∫
                    lines = ["‚úÖ –û—Ä–¥–µ—Ä–∏:"]
                    for od in placed:
                        if "symbol" in od and "id" in od:
                            lines.append(f"‚Ä¢ {od['symbol']} ‚Üí OK (id {od['id']})")
                        elif "symbol" in od and "error" in od:
                            lines.append(f"‚Ä¢ {od['symbol']} ‚Üí ‚ùå {od['error']}")
                        else:
                            lines.append(f"‚Ä¢ {od}")
                    out = "\n".join(lines)
                    await update.message.reply_text(out)
    except Exception as e:
        await update.message.reply_text(f"‚ùå Scan error: {e}")

# =========================
# –ê–≤—Ç–æ—Å–∫–∞–Ω —É —Ñ–æ–Ω—ñ
# =========================

async def periodic_scan(app: Application):
    await asyncio.sleep(3)
    while True:
        try:
            if not ALPACA_ENABLE:
                await asyncio.sleep(SCAN_EVERY_SEC)
                continue

            # –∫–æ–ø—ñ—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–æ—Ö–æ–¥—É
            chats = list(STATE.items())
            if not chats:
                await asyncio.sleep(SCAN_EVERY_SEC)
                continue

            async with aiohttp.ClientSession() as sess:
                rep, picks_s, picks_c = await scan_universe(sess, {"mode": "default"})
                for chat_id, st in chats:
                    try:
                        if st.get("autotrade"):
                            merged = []
                            if picks_s: merged.extend(picks_s[: max(1, len(picks_s)//2)])
                            if picks_c: merged.extend(picks_c[: max(1, len(picks_c)//2)])
                            if merged:
                                placed = await place_top_orders(sess, merged, st)
                                lines = [f"ü§ñ AUTOTRADE @ {now_utc_str()}"]
                                for od in placed:
                                    if "symbol" in od and "id" in od:
                                        lines.append(f"‚Ä¢ {od['symbol']} ‚Üí OK (id {od['id']})")
                                    elif "symbol" in od and "error" in od:
                                        lines.append(f"‚Ä¢ {od['symbol']} ‚Üí ‚ùå {od['error']}")
                                    else:
                                        lines.append(f"‚Ä¢ {od}")
                                await app.bot.send_message(chat_id, "\n".join(lines))
                    except Exception:
                        pass
        except Exception:
            pass
        await asyncio.sleep(SCAN_EVERY_SEC)

# =========================
# main
# =========================

def ensure_siglog_header():
    if not SIGLOG_PATH:
        return
    if not os.path.exists(SIGLOG_PATH):
        with open(SIGLOG_PATH, "w", encoding="utf-8") as f:
            f.write("timestamp,report\n")

async def main():
    if not TG_TOKEN:
        raise RuntimeError("Missing TELEGRAM_BOT_TOKEN")
    if not (ALPACA_KEY and ALPACA_SECRET):
        print("WARN: Alpaca keys missing ‚Äî —Å—Ç–∞—Ç—É—Å –º–æ–∂–µ –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏.")
    ensure_siglog_header()

    app = Application.builder().token(TG_TOKEN).build()

    # –ö–æ–º–∞–Ω–¥–∏
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))

    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", alp_status_cmd))

    app.add_handler(CommandHandler("signals_alpaca", signals_cmd))

    app.add_handler(CommandHandler("aggressive", aggressive_cmd))
    app.add_handler(CommandHandler("scalp", scalp_cmd))
    app.add_handler(CommandHandler("default", default_cmd))
    app.add_handler(CommandHandler("swing", swing_cmd))
    app.add_handler(CommandHandler("safe", safe_cmd))

    # –ù–∞ –≤—Å—è–∫ –≤–∏–ø–∞–¥–æ–∫: –ø—Ä–∏ —Ç–µ–∫—Å—Ç—ñ /start –±–µ–∑ —Å–ª–µ—à–∞ —Ç–æ—â–æ
    app.add_handler(MessageHandler(filters.Regex(r"^/start$"), start_cmd))

    await set_bot_commands(app)
    app.create_task(periodic_scan(app))  # —Ñ–æ–Ω–æ–≤–∏–π –∞–≤—Ç–æ—Ç—Ä–µ–π–¥

    print("Bot started.")
    await app.run_polling(close_loop=False)

if __name__ == "__main__":
    asyncio.run(main())
