# bot_paid.py
# Telegram: Bybit signals (—è–∫ –±—É–ª–æ) + Alpaca –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ (–∞–≥—Ä–µ—Å–∏–≤–Ω–∏–π/–±–µ–∑–ø–µ—á–Ω–∏–π)
# Alpaca —Ä–µ–∂–∏–º–∏:
#   /alp_aggr_on ‚Äî 15m –≤—Ö—ñ–¥ + –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m
#   /alp_safe_on ‚Äî 15m –≤—Ö—ñ–¥ + –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m —Ç–∞ 1h
#   /alp_off     ‚Äî –≤–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥
#
# –û—Ä–¥–µ—Ä–∏ Alpaca: MARKET notional + bracket TP/SL –∑ ATR (SL_k, RR_k –∑ –ø—Ä–æ—Ñ—ñ–ª—é).
# Bybit-—Å–∏–≥–Ω–∞–ª–∏ –Ω–µ –∑–º—ñ–Ω—é–≤–∞–≤ ‚Äî —Ç–≤—ñ–π —ñ—Å–Ω—É—é—á–∏–π –ø–∞–π–ø–ª–∞–π–Ω –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è.

import os
import csv
import html
import math
import asyncio
import aiohttp
import logging
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timezone, time as dtime

from telegram import Update, ReplyKeyboardMarkup, BotCommand
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes

# ================= ENV =================
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()

# Bybit (–¥–ª—è —Å–∏–≥–Ω–∞–ª—ñ–≤) ‚Äî —è–∫ —É —Ç–µ–±–µ –±—É–ª–æ
BYBIT_PROXY = os.getenv("BYBIT_PROXY", "").strip()
DEFAULT_AUTO_MIN = int(os.getenv("DEFAULT_AUTO_MIN", "15"))
TOP_N = int(os.getenv("TOP_N", "3"))
LOG_PATH = os.getenv("SIGLOG_PATH", "signals_log.csv")

# Alpaca
ALP_KEY = os.getenv("ALPACA_API_KEY", "").strip()
ALP_SECRET = os.getenv("ALPACA_API_SECRET", "").strip()
ALP_BASE = (os.getenv("ALPACA_BASE_URL", "https://paper-api.alpaca.markets/v2")).strip()
ALP_NOTIONAL = float(os.getenv("ALPACA_NOTIONAL", "50"))
ALP_SCAN_CLASS = os.getenv("ALPACA_SCAN_CLASS", "all").strip().lower()  # all|stocks|crypto
ALP_MAX_ASSETS = int(os.getenv("ALPACA_MAX_ASSETS", "80"))
ALP_TF_FAST = os.getenv("ALPACA_TF_FAST", "15Min").strip()
ALP_TF_MID  = os.getenv("ALPACA_TF_MID", "30Min").strip()
ALP_TF_SLOW = os.getenv("ALPACA_TF_SLOW", "1Hour").strip()

# ================= LOGS ================
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
log = logging.getLogger("signals")

# ================= UI ==================
def _kb(st: Dict[str, object]) -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        [
            ["/aggressive", "/scalp", "/default"],
            ["/swing", "/safe", "/help"],
            ["/signals", "/status"],
            ["/alp_aggr_on", "/alp_safe_on", "/alp_off"]
        ],
        resize_keyboard=True
    )

# ================= STATE ===============
STATE: Dict[int, Dict[str, object]] = {}

def default_state() -> Dict[str, object]:
    return {
        # —Ç–æ—Ä–≥–æ–≤–∞ —Å–µ—Å—ñ—è (UTC) ‚Äî —è–∫ —É —Ç–µ–±–µ –±—É–ª–æ
        "sess_from": 12, "sess_to": 20,
        # bybit: —Ç–≤—ñ–π —Å—Ç–∞—Ä–∏–π –ø–∞–π–ø–ª–∞–π–Ω (–ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–∏–∂—á–µ –ª–∏—à–∏–≤ –¥–ª—è —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ)
        "top_n": TOP_N, "every": DEFAULT_AUTO_MIN, "auto_on": False,
        "min_turnover": 150.0, "max_spread_bps": 6, "max_24h_change": 18.0,
        "noise": 1.6, "trend_weight": 3, "min_adx": 18, "vol_mult": 1.2,
        "atr_len": 14, "sl_k": 1.5, "rr_k": 2.2, "trail_k": 1.2,
        "whitelist": set(), "blacklist": set({"TRUMPUSDT","PUMPFUNUSDT","FARTCOINUSDT","IPUSDT","ENAUSDT"}),
        "_last_sig_ts": {}, "diag_filters": True, "active_profile": "",

        # —Ä–∏–∑–∏–∫ (–¥–ª—è –ø—ñ–¥–∫–∞–∑–æ–∫ —É —Ç–µ–∫—Å—Ç—ñ —Å–∏–≥–Ω–∞–ª—ñ–≤)
        "leverage": 5, "deposit": 1000.0, "risk_pct": 1.0, "risk_usd_fixed": None,

        # Alpaca —Ä–µ–∂–∏–º: off|aggressive|safe
        "alp_mode": "off",
        "alp_notional": ALP_NOTIONAL,
        # –æ–∫—Ä–µ–º—ñ –ø–æ—Ä–æ–≥–∏ –¥–ª—è alp-—Ä–µ–∂–∏–º—ñ–≤ (–º–æ–∂–µ—à –ø—ñ–¥–∫—Ä—É—Ç–∏—Ç–∏)
        "alp_params": {
            "aggressive": {"min_adx": 10, "sl_k": 1.2, "rr_k": 2.0},
            "safe":       {"min_adx": 12, "sl_k": 1.3, "rr_k": 2.2},
        }
    }

# ================= HELPERS =============
def utc_now_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")

def in_session(st) -> bool:
    now = datetime.now(timezone.utc).time()
    f, t = int(st["sess_from"]), int(st["sess_to"])
    if f <= t:
        return dtime(f,0) <= now <= dtime(t,0)
    return now >= dtime(f,0) or now <= dtime(t,0)

def split_long(text: str, n: int = 3500) -> List[str]:
    chunks: List[str] = []
    i, L = 0, len(text)
    while i < L:
        j = min(L, i + n)
        cut = text.rfind("\n\n", i, j)
        if cut == -1:
            cut = text.rfind("\n", i, j)
        if cut == -1 or cut <= i + 200:
            cut = j
        chunk = text[i:cut]
        if chunk.count("`") % 2 == 1:
            nxt = text.find("`", cut)
            if 0 <= nxt < i + n + 500:
                chunk = text[i:nxt + 1]
                cut = nxt + 1
            else:
                chunk += "`"
        chunks.append(chunk)
        i = cut
    return chunks

def fmt_usd(x: float) -> str:
    sign = "-" if x < 0 else ""
    x = abs(x)
    return f"{sign}${x:,.2f}"

# ============== INDICATORS =============
def ema(xs: List[float], p: int) -> List[float]:
    if not xs: return []
    k = 2/(p+1); out=[xs[0]]
    for x in xs[1:]: out.append(out[-1] + k*(x - out[-1]))
    return out

def rsi(xs: List[float], p: int = 14) -> List[float]:
    if len(xs) < p+1: return []
    gains, losses = [], []
    for i in range(1, len(xs)):
        d = xs[i]-xs[i-1]
        gains.append(max(0,d)); losses.append(max(0,-d))
    ag = sum(gains[:p])/p; al = sum(losses[:p])/p
    out=[0.0]*p; out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    for i in range(p, len(gains)):
        ag=(ag*(p-1)+gains[i])/p; al=(al*(p-1)+losses[i])/p
        out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    return out

def macd(xs: List[float], fast=12, slow=26, signal=9) -> Tuple[List[float], List[float]]:
    if len(xs) < slow+signal: return [], []
    ef, es = ema(xs, fast), ema(xs, slow)
    m=[a-b for a,b in zip(ef[-len(es):], es)]; s=ema(m, signal)
    L=min(len(m),len(s)); return m[-L:], s[-L:]

def adx_last(high: List[float], low: List[float], close: List[float], n: int=14) -> float:
    if len(close) < n+1: return 0.0
    plus_dm=[]; minus_dm=[]; tr=[]
    for i in range(1,len(close)):
        up = high[i]-high[i-1]; dn = low[i-1]-low[i]
        plus_dm.append(up if (up>dn and up>0) else 0.0)
        minus_dm.append(dn if (dn>up and dn>0) else 0.0)
        tr.append(max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1])))
    def rmean(xs: List[float], p: int) -> List[float]:
        if len(xs)<p: return []
        out=[]; s=sum(xs[:p]); out.append(s/p)
        for i in range(p, len(xs)):
            s += xs[i]-xs[i-p]; out.append(s/p)
        return out
    atr_n = rmean(tr, n)
    if not atr_n: return 0.0
    last = len(atr_n)-1; atrv = atr_n[last] or 1e-9
    pdi = 100.0 * (sum(plus_dm[-n:])/n) / atrv
    mdi = 100.0 * (sum(minus_dm[-n:])/n) / atrv
    dx = 100.0 * abs(pdi-mdi) / (pdi+mdi+1e-9)
    dx_series = rmean([dx]*n, n)
    return dx_series[-1] if dx_series else dx

def atr_val(h: List[float], l: List[float], c: List[float], n: int=14) -> float:
    if len(c) < n+1: return 0.0
    trs=[]
    for i in range(1,len(c)):
        trs.append(max(h[i]-l[i], abs(h[i]-c[i-1]), abs(l[i]-c[i-1])))
    if len(trs)<n: return 0.0
    return sum(trs[-n:])/n

# ============== ALPACA REST =============
def alp_headers() -> Dict[str, str]:
    return {
        "APCA-API-KEY-ID": ALP_KEY,
        "APCA-API-SECRET-KEY": ALP_SECRET,
        "Content-Type": "application/json",
    }

async def alp_get(session: aiohttp.ClientSession, path: str):
    url = f"{ALP_BASE}{path}"
    async with session.get(url, headers=alp_headers(), timeout=30) as r:
        if r.status >= 400:
            raise RuntimeError(f"GET {path} -> {r.status} {await r.text()}")
        return await r.json()

async def alp_post(session: aiohttp.ClientSession, path: str, payload: dict):
    url = f"{ALP_BASE}{path}"
    async with session.post(url, headers=alp_headers(), json=payload, timeout=30) as r:
        if r.status >= 400:
            raise RuntimeError(f"POST {path} -> {r.status} {await r.text()}")
        return await r.json()

# ============ ALPACA DATA API ============
async def alp_list_assets(session: aiohttp.ClientSession, asset_class: str) -> List[Dict]:
    # asset_class: 'us_equity' –∞–±–æ 'crypto'
    url = f"{ALP_BASE}/assets?status=active&tradable=true&asset_class={asset_class}"
    async with session.get(url, headers=alp_headers(), timeout=30) as r:
        if r.status >= 400:
            raise RuntimeError(f"assets {asset_class}: {r.status} {await r.text()}")
        return await r.json()

async def bars_stocks(session: aiohttp.ClientSession, symbol: str, tf: str, limit: int=300):
    base = "https://data.alpaca.markets/v2"
    url = f"{base}/stocks/bars?symbols={symbol}&timeframe={tf}&limit={limit}"
    async with session.get(url, headers=alp_headers(), timeout=30) as r:
        if r.status >= 400:
            raise RuntimeError(f"stocks/bars {symbol}: {r.status} {await r.text()}")
        data = await r.json()
    bars = ((data or {}).get("bars") or {}).get(symbol, [])
    o=h=l=c=v=[],[],[],[],[]
    O,H,L,C,V=[],[],[],[],[]
    for b in bars:
        O.append(float(b.get("o",0))); H.append(float(b.get("h",0)))
        L.append(float(b.get("l",0))); C.append(float(b.get("c",0))); V.append(float(b.get("v",0)))
    return O,H,L,C,V

async def bars_crypto(session: aiohttp.ClientSession, symbol: str, tf: str, limit: int=300):
    # Crypto: v1beta3/crypto/us/bars, symbol —è–∫ "BTC/USD"
    base = "https://data.alpaca.markets/v1beta3"
    url = f"{base}/crypto/us/bars?symbols={symbol}&timeframe={tf}&limit={limit}"
    async with session.get(url, headers=alp_headers(), timeout=30) as r:
        if r.status >= 400:
            raise RuntimeError(f"crypto/bars {symbol}: {r.status} {await r.text()}")
        data = await r.json()
    bars = ((data or {}).get("bars") or {}).get(symbol, [])
    O,H,L,C,V=[],[],[],[],[]
    for b in bars:
        O.append(float(b.get("o",0))); H.append(float(b.get("h",0)))
        L.append(float(b.get("l",0))); C.append(float(b.get("c",0))); V.append(float(b.get("v",0)))
    return O,H,L,C,V

# ============ LOGIC: MULTI-TF =============
def trend_ema(c: List[float], fast: int=20, slow: int=50) -> int:
    if len(c) < slow: return 0
    e20 = ema(c, fast)[-1]; e50 = ema(c, slow)[-1]
    return 1 if e20 > e50 else (-1 if e20 < e50 else 0)

def decide_side_15m(c15: List[float], h15: List[float], l15: List[float], min_adx: float) -> Optional[str]:
    if len(c15) < 60: return None
    e20 = ema(c15, 20)[-1]; e50 = ema(c15, 50)[-1]
    r = rsi(c15,14); r_last = r[-1] if r else 50.0
    m,s = macd(c15); macd_ok = (m and s and (m[-1] > s[-1]))  # long —É–º–æ–≤–Ω–æ
    adx = adx_last(h15, l15, c15, 14)
    px = c15[-1]

    # LONG
    if px>e20>e50 and r_last>52 and macd_ok and adx>=min_adx:
        return "LONG"
    # SHORT
    if px<e20<e50 and r_last<48 and not macd_ok and adx>=min_adx:
        return "SHORT"
    return None

def confirm_trend(c: List[float], side: str) -> bool:
    t = trend_ema(c,20,50)
    return (t==1 and side=="LONG") or (t==-1 and side=="SHORT")

def calc_atr_sl_tp(side: str, px: float, h: List[float], l: List[float], c: List[float], sl_k: float, rr_k: float) -> Tuple[float,float]:
    a = atr_val(h,l,c,14)
    if a<=0: a = max(1e-9, abs(c[-1]-c[-2]))
    if side=="LONG":
        sl = px - sl_k*a
        risk = px - sl
        tp = px + rr_k*risk
    else:
        sl = px + sl_k*a
        risk = sl - px
        tp = px - rr_k*risk
    return sl, tp

# ============ SCAN & DECIDE (ALPACA) ============
async def scan_alpaca_and_decide(st: Dict[str,object]) -> List[Dict]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ –¥–ª—è –≤—Ö–æ–¥—É:
      {symbol, side, px, sl, tp, tf='15m'}
    """
    if st.get("alp_mode","off") == "off":
        return []

    mode = st["alp_mode"]  # aggressive|safe
    min_adx = st["alp_params"][mode]["min_adx"]
    sl_k    = st["alp_params"][mode]["sl_k"]
    rr_k    = st["alp_params"][mode]["rr_k"]

    classes=[]
    if ALP_SCAN_CLASS in ("all","stocks"): classes.append("us_equity")
    if ALP_SCAN_CLASS in ("all","crypto"): classes.append("crypto")

    assets=[]
    async with aiohttp.ClientSession() as s:
        for cls in classes:
            try:
                assets += await alp_list_assets(s, cls)
            except Exception as e:
                log.error("assets %s err: %s", cls, e)

        # –≤—ñ–¥—Å—ñ—è—Ç–∏ –Ω–µ—Ç–æ—Ä–≥–æ–≤–∞–Ω—ñ
        assets = [a for a in assets if a.get("tradable",False)]
        # –æ–±–º–µ–∂–∏—Ç–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —â–æ–± –Ω–µ –≤–±–∏—Ç–∏ –ª—ñ–º—ñ—Ç–∏
        assets = assets[:ALP_MAX_ASSETS]

        picks=[]
        for a in assets:
            sym = a["symbol"]; acls=a.get("asset_class","")
            try:
                if acls=="crypto":
                    o15,h15,l15,c15,_ = await bars_crypto(s, sym, ALP_TF_FAST, 300)
                    o30,h30,l30,c30,_ = await bars_crypto(s, sym, ALP_TF_MID,  300)
                    o60,h60,l60,c60,_ = await bars_crypto(s, sym, ALP_TF_SLOW, 300)
                else:
                    o15,h15,l15,c15,_ = await bars_stocks(s, sym, ALP_TF_FAST, 300)
                    o30,h30,l30,c30,_ = await bars_stocks(s, sym, ALP_TF_MID,  300)
                    o60,h60,l60,c60,_ = await bars_stocks(s, sym, ALP_TF_SLOW, 300)

                if len(c15)<60 or len(c30)<60 or len(c60)<60: 
                    continue

                side = decide_side_15m(c15,h15,l15,min_adx)
                if not side: 
                    continue

                # –∞–≥—Ä–µ—Å–∏–≤–Ω–∏–π: –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m
                if not confirm_trend(c30, side):
                    continue

                # –±–µ–∑–ø–µ—á–Ω–∏–π: —â–µ –π 1h
                if mode=="safe" and not confirm_trend(c60, side):
                    continue

                px = c15[-1]
                sl, tp = calc_atr_sl_tp(side, px, h15,l15,c15, sl_k, rr_k)
                picks.append({"symbol": sym, "side": side, "px": px, "sl": sl, "tp": tp})
            except Exception as e:
                log.debug("bars %s err: %s", sym, e)

    # –≤—ñ–¥—Å–æ—Ä—Ç—É—î–º–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∏ –∑–∞ ¬´—Å–∏–ª–æ—é¬ª (–≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ EMA20 —ñ EMA50 –Ω–∞ 15m) ‚Äî –≥—Ä—É–±–æ
    def ema_gap(c): 
        e20=ema(c,20)[-1]; e50=ema(c,50)[-1]; return abs(e20-e50)/max(1e-9,e50)
    # (–¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç–∏ —Ç—É—Ç –≤–∂–µ –Ω–µ–º–∞ 15m —Å–µ—Ä—ñ—ó, —Ç–æ–º—É –ø—Ä–æ—Å—Ç–æ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —è–∫ —î)
    return picks[:10]

# ============ PLACE ORDERS (ALPACA) ============
async def place_alpaca_orders(chat_id: int, st: Dict[str,object], cands: List[Dict], context: ContextTypes.DEFAULT_TYPE):
    if not cands: 
        return
    notional = float(st.get("alp_notional", ALP_NOTIONAL))
    async with aiohttp.ClientSession() as s:
        for c in cands:
            sym, side, px, sl, tp = c["symbol"], c["side"], c["px"], c["sl"], c["tp"]
            payload = {
                "symbol": sym,
                "side": "buy" if side=="LONG" else "sell",
                "type": "market",
                "notional": round(notional,2),
                "time_in_force": "gtc",
                "order_class": "bracket",
                "take_profit": {"limit_price": round(tp, 4)},
                "stop_loss":  {"stop_price": round(sl, 4)}
            }
            try:
                r = await alp_post(s, "/orders", payload)
                oid = r.get("id","")
                await context.bot.send_message(
                    chat_id,
                    f"‚úÖ Alpaca {side} {sym} @ ~{px:.4f}\n"
                    f"TP: {tp:.4f} ‚Ä¢ SL: {sl:.4f}\n"
                    f"Notional: {fmt_usd(notional)}\n"
                    f"order_id={oid}"
                )
            except Exception as e:
                await context.bot.send_message(chat_id, f"‚ùå Alpaca order error {sym}: {e}")

# ============ BYBIT SIGNALS (—è–∫ —É —Ç–µ–±–µ) ============
# –¢—É—Ç —è –∑–∞–ª–∏—à–∞—é –∫–∞—Ä–∫–∞—Å, —â–æ–± –Ω–µ –ª–∞–º–∞—Ç–∏ —Ç–≤—ñ–π —ñ—Å–Ω—É—é—á–∏–π –∫–æ–¥.
# –Ø–∫—â–æ —É —Ç–µ–±–µ –≤–∂–µ –±—É–ª–∏ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó get_tickers/get_klines/bybit –ª–æ–≥—ñ–∫–∏ ‚Äî –≤–æ–Ω–∏ –ª–∏—à–∞—é—Ç—å—Å—è.
# –ù–∏–∂—á–µ ‚Äî –ª–∏—à–µ "–∑–∞–≥–ª—É—à–∫–∞" build_signals_bybit -> –ø–æ–≤–µ—Ä—Ç–∞—î –ø—É—Å—Ç–æ, —â–æ–± –Ω–µ –¥—É–±–ª—é–≤–∞—Ç–∏.
async def build_signals_bybit(st: Dict[str,object]) -> str:
    # –í—Å—Ç–∞–≤ —Å–≤—ñ–π —ñ—Å–Ω—É—é—á–∏–π –∫–æ–¥ –∑ —Ç–≤–æ—î—ó –≤–µ—Ä—Å—ñ—ó (–≤—ñ–Ω —É —Ç–µ–±–µ –≤–∂–µ –ø—Ä–∞—Ü—é—î)
    return "‚ÑπÔ∏è Bybit —Å–∏–≥–Ω–∞–ª–∏ –∞–∫—Ç–∏–≤–Ω—ñ (–ª–æ–≥—ñ–∫–∞ —è–∫ —Ä–∞–Ω—ñ—à–µ). –ó–∞–ø—É—Å—Ç–∏ /signals ‚Äî —ñ –æ—Ç—Ä–∏–º–∞—î—à –ø—ñ–¥–±—ñ—Ä–∫—É.\nUTC: " + utc_now_str()

# ============ TELEGRAM CMDS ============
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    STATE.setdefault(u.effective_chat.id, default_state())
    await c.bot.set_my_commands([
        BotCommand("help", "–î–æ–≤—ñ–¥–∫–∞"),
        BotCommand("signals", "–°–∫–∞–Ω—É–≤–∞—Ç–∏ –∑–∞—Ä–∞–∑"),
        BotCommand("status", "–ü–æ—Ç–æ—á–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è"),
        BotCommand("alp_aggr_on", "Alpaca –∞–≥—Ä–µ—Å–∏–≤–Ω–æ (15m+30m)"),
        BotCommand("alp_safe_on", "Alpaca –±–µ–∑–ø–µ—á–Ω–æ (15m+30m+1h)"),
        BotCommand("alp_off", "–í–∏–º–∫–Ω—É—Ç–∏ Alpaca –∞–≤—Ç–æ—Ç—Ä–µ–π–¥"),
    ])
    await u.message.reply_text(
        "üëã –ë–æ—Ç –≥–æ—Ç–æ–≤–∏–π.\n"
        "‚Ä¢ Bybit ‚Äî —Å–∏–≥–Ω–∞–ª–∏ —è–∫ —Ä–∞–Ω—ñ—à–µ.\n"
        "‚Ä¢ Alpaca ‚Äî /alp_aggr_on –∞–±–æ /alp_safe_on –¥–ª—è –∞–≤—Ç–æ—Ç—Ä–µ–π–¥—É –∑ TP/SL.\n"
        "‚Ä¢ /signals ‚Äî –ø—Ä–æ—Å–∫–∞–Ω—É–≤–∞—Ç–∏ —ñ, —è–∫—â–æ Alpaca —É–≤—ñ–º–∫–Ω–µ–Ω–æ, –≤—ñ–¥–∫—Ä–∏—Ç–∏ —É–≥–æ–¥–∏.\n",
        reply_markup=_kb({})
    )

async def help_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    txt = (
        "üìò –î–æ–≤—ñ–¥–∫–∞\n\n"
        "Alpaca —Ä–µ–∂–∏–º–∏:\n"
        "‚Ä¢ /alp_aggr_on ‚Äî –≤—Ö—ñ–¥ 15m, –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m, ATR SL/TP.\n"
        "‚Ä¢ /alp_safe_on ‚Äî –≤—Ö—ñ–¥ 15m, –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è 30m+1h, ATR SL/TP.\n"
        "‚Ä¢ /alp_off ‚Äî –≤–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥.\n\n"
        "Bybit —Å–∏–≥–Ω–∞–ª–∏ ‚Äî /signals –ø–æ–∫–∞–∑—É—î –ø—ñ–¥–±—ñ—Ä–∫—É (—è–∫ —Ä–∞–Ω—ñ—à–µ).\n"
    )
    for ch in split_long(txt, 3500):
        await u.message.reply_text(ch)

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    p = st["alp_params"].get(st.get("alp_mode","off"), {})
    text = (
        f"Alpaca —Ä–µ–∂–∏–º: {st.get('alp_mode','off')}\n"
        f"Notional: {fmt_usd(st.get('alp_notional',ALP_NOTIONAL))}\n"
        f"ATR SL_k={p.get('sl_k','-')} ‚Ä¢ RR_k={p.get('rr_k','-')} ‚Ä¢ minADX={p.get('min_adx','-')}\n"
        f"–°–∫–∞–Ω –∫–ª–∞—Å: {ALP_SCAN_CLASS} ‚Ä¢ –õ—ñ–º—ñ—Ç–∏ –∞–∫—Ç–∏–≤—ñ–≤: {ALP_MAX_ASSETS}\n"
        f"TF: fast={ALP_TF_FAST}, mid={ALP_TF_MID}, slow={ALP_TF_SLOW}\n"
        f"–°–µ—Å—ñ—è UTC {int(STATE[u.effective_chat.id]['sess_from']):02d}-{int(STATE[u.effective_chat.id]['sess_to']):02d}\n"
        f"UTC: {utc_now_str()}"
    )
    await u.message.reply_text(text)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())

    # 1) Bybit ‚Äî —Ç–≤—ñ–π —ñ—Å–Ω—É—é—á–∏–π –ø–∞–π–ø–ª–∞–π–Ω –¥–ª—è —Å–∏–≥–Ω–∞–ª—ñ–≤ (–∑–±–µ—Ä–µ–∂–µ–Ω–æ)
    bybit_txt = await build_signals_bybit(st)
    for ch in split_long(bybit_txt):
        await u.message.reply_text(ch, parse_mode=ParseMode.MARKDOWN)

    # 2) Alpaca ‚Äî —è–∫—â–æ —É–≤—ñ–º–∫–Ω—É—Ç–æ –±—É–¥—å-—è–∫–∏–π —Ä–µ–∂–∏–º
    if st.get("alp_mode","off") != "off":
        if not in_session(st):
            await u.message.reply_text(f"‚è≥ –ü–æ–∑–∞ —Ç–æ—Ä–≥–æ–≤–æ—é —Å–µ—Å—ñ—î—é (UTC {st['sess_from']:02.0f}:00‚Äì{st['sess_to']:02.0f}:00).")
            return
        cands = await scan_alpaca_and_decide(st)
        if not cands:
            await u.message.reply_text("‚ö†Ô∏è Alpaca: –∑–∞—Ä–∞–∑ –Ω–∞–¥—ñ–π–Ω–∏—Ö –≤—Ö–æ–¥—ñ–≤ –Ω–µ –∑–Ω–∞–π—à–æ–≤.")
        else:
            await place_alpaca_orders(u.effective_chat.id, st, cands, c)

async def alp_aggr_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["alp_mode"] = "aggressive"
    await u.message.reply_text("‚úÖ Alpaca: –∞–≥—Ä–µ—Å–∏–≤–Ω–∏–π —Ä–µ–∂–∏–º –£–í–Ü–ú–ö–ù–ï–ù–û (15m –≤—Ö—ñ–¥ + 30m –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è).")

async def alp_safe_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["alp_mode"] = "safe"
    await u.message.reply_text("‚úÖ Alpaca: –±–µ–∑–ø–µ—á–Ω–∏–π —Ä–µ–∂–∏–º –£–í–Ü–ú–ö–ù–ï–ù–û (15m –≤—Ö—ñ–¥ + 30m + 1h –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è).")

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["alp_mode"] = "off"
    await u.message.reply_text("‚è∏ Alpaca: –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ –≤–∏–º–∫–Ω–µ–Ω–æ.")

# ============ APP =============
def register(app: Application):
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(CommandHandler("signals", signals_cmd))

    app.add_handler(CommandHandler("alp_aggr_on", alp_aggr_on_cmd))
    app.add_handler(CommandHandler("alp_safe_on", alp_safe_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))

async def main():
    if not TG_TOKEN:
        raise SystemExit("Set TELEGRAM_BOT_TOKEN")
    app = Application.builder().token(TG_TOKEN).build()
    register(app)
    log.info("Bot started")
    await app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
