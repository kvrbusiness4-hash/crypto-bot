# bot.py
# Telegram —Å–º–∞—Ä—Ç-–∞–≤—Ç–æ—Ç—Ä–µ–π–¥ –±–æ—Ç –¥–ª—è Alpaca (stocks + crypto 24/7)
# –ë–µ–∑ –±—É–¥—å-—è–∫–∏—Ö –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫ —Ç–æ—Ä–≥–æ–≤–∏—Ö —Å–µ—Å—ñ–π/–≥–æ–¥–∏–Ω ‚Äî –∑–∞–≤–∂–¥–∏ —Å–∫–∞–Ω—É—î –π —Ç–æ—Ä–≥—É—î.
# –ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ: python-telegram-bot>=20, aiohttp

import os
import csv
import io
import math
import asyncio
import datetime as dt
from typing import Dict, List, Tuple, Optional

import aiohttp
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
)

# ==========================
# ENV & –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏
# ==========================
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()

ALP_BASE = os.getenv("ALPACA_BASE_URL", "https://paper-api.alpaca.markets").rstrip("/")
ALP_DATA = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets").rstrip("/")

ALP_KEY = os.getenv("ALPACA_API_KEY", "").strip()
ALP_SEC = os.getenv("ALPACA_API_SECRET", "").strip()

# —Å–∫—ñ–ª—å–∫–∏ USD –Ω–∞ –æ–¥–Ω—É —É–≥–æ–¥—É
NOTIONAL = float(os.getenv("ALPACA_NOTIONAL", "50"))
# —á–∏ –¥–æ–∑–≤–æ–ª–µ–Ω–æ –≤–∏—Å—Ç–∞–≤–ª—è—Ç–∏ –æ—Ä–¥–µ—Ä–∏
AUTOTRADE_ENABLED_BY_ENV = os.getenv("ALPACA_ENABLE", "1") in ("1", "true", "True")
# –º–µ–∂—ñ –¥–ª—è —Å–∫–∞–Ω—É
MAX_STOCKS = int(os.getenv("ALPACA_MAX_STOCKS", "300"))
MAX_CRYPTO = int(os.getenv("ALPACA_MAX_CRYPTO", "100"))

SIGLOG_PATH = os.getenv("SIGLOG_PATH", "").strip()  # –Ω–∞–ø—Ä. "signals_log.csv" (–Ω–µ–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ)

HEADERS = {
    "APCA-API-KEY-ID": ALP_KEY,
    "APCA-API-SECRET-KEY": ALP_SEC,
}

# –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó –∑–∞ –ø—Ä–æ—Ñ—ñ–ª—è–º–∏
PROFILES = {
    "aggressive": dict(tf="15Min", lookback=48, min_score=0.7),
    "scalp":      dict(tf="5Min",  lookback=72, min_score=0.8),
    "default":    dict(tf="15Min", lookback=64, min_score=0.8),
    "swing":      dict(tf="1Hour", lookback=120, min_score=0.65),
    "safe":       dict(tf="1Hour", lookback=168, min_score=0.85),
}

# ==========================
# –°—Ç–∞–Ω –Ω–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
# ==========================
def default_state() -> Dict:
    return {
        "profile": "default",
        "autotrade": AUTOTRADE_ENABLED_BY_ENV,  # –º–æ–∂–Ω–∞ –ø–æ–º—ñ–Ω—è—Ç–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏ /alp_on /alp_off
        "wl_stocks": [],   # –ø—É—Å—Ç–æ => —Å–∫–∞–Ω—É—î–º–æ –í–°–Ü
        "wl_crypto": [],   # –ø—É—Å—Ç–æ => —Å–∫–∞–Ω—É—î–º–æ –í–°–Ü
        "last_scan_txt": "",
    }

STATE: Dict[int, Dict] = {}  # chat_id -> state


# ==========================
# –£—Ç–∏–ª—ñ—Ç–∏
# ==========================
def now_utc() -> str:
    return dt.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

def fmt_usd(x: float) -> str:
    return f"${x:,.2f}"

def csv_bytes(rows: List[List[str]]) -> bytes:
    buf = io.StringIO()
    w = csv.writer(buf)
    for r in rows:
        w.writerow(r)
    return buf.getvalue().encode("utf-8")


# ==========================
# HTTP –¥–æ Alpaca
# ==========================
async def alp_get(session: aiohttp.ClientSession, url: str, params=None):
    async with session.get(url, headers=HEADERS, params=params, timeout=30) as r:
        if r.status >= 400:
            txt = await r.text()
            raise RuntimeError(f"GET {url} {r.status}: {txt}")
        return await r.json()

async def alp_post(session: aiohttp.ClientSession, url: str, json=None):
    async with session.post(url, headers=HEADERS, json=json, timeout=30) as r:
        if r.status >= 400:
            txt = await r.text()
            raise RuntimeError(f"POST {url} {r.status}: {txt}")
        return await r.json()


# ==========================
# Alpaca: –∞–∫–∞—É–Ω—Ç/–∞–∫—Ç–∏–≤–∏/–±–∞—Ä–∏
# ==========================
async def alp_account(session: aiohttp.ClientSession) -> Dict:
    return await alp_get(session, f"{ALP_BASE}/v2/account")

async def alp_assets(session: aiohttp.ClientSession) -> Tuple[List[str], List[str]]:
    """–ü–æ–≤–µ—Ä—Ç–∞—î (tickers_equities, symbols_crypto). –ë–µ–∑ whitelist ‚Äî —É—Å–µ –∞–∫—Ç–∏–≤–Ω–µ/—Ç–æ—Ä–≥–æ–≤–∞–Ω–µ."""
    assets = await alp_get(session, f"{ALP_BASE}/v2/assets", params={"status": "active", "tradable": "true"})
    stocks, crypto = [], []
    for a in assets:
        c = a.get("class")
        sym = a.get("symbol")
        if not sym:
            continue
        if c == "us_equity":
            stocks.append(sym)
        elif c == "crypto":
            # —É Alpaca crypto –≤–∂–µ —Ñ–æ—Ä–º–∞—Ç—É BTC/USD, ETH/USD —ñ —Ç.–¥.
            crypto.append(sym)
    # –æ–±–º–µ–∂—É—î–º–æ –≤–µ—Ä—Ö–Ω—ñ –º–µ–∂—ñ
    return stocks[:MAX_STOCKS], crypto[:MAX_CRYPTO]

async def bars_stocks(session: aiohttp.ClientSession, symbols: List[str], tf: str, lookback: int) -> Dict[str, List[Dict]]:
    """/v2/stocks/bars"""
    if not symbols:
        return {}
    # Alpaca –æ–±–º–µ–∂—É—î –ø–∞—á–∫–∏ —Å–∏–º–≤–æ–ª—ñ–≤; –∑—Ä–æ–±–∏–º–æ –±–∞—Ç—á–∞–º–∏ –ø–æ 100
    out = {}
    end = dt.datetime.utcnow()
    start = end - dt.timedelta(minutes=lookback*5 if tf.endswith("Min") else lookback*60)
    params_template = {
        "timeframe": tf,
        "start": start.isoformat() + "Z",
        "end": end.isoformat() + "Z",
        "limit": lookback + 2,
        "adjustment": "all",
    }
    for i in range(0, len(symbols), 100):
        syms = symbols[i:i+100]
        params = params_template | {"symbols": ",".join(syms)}
        j = await alp_get(session, f"{ALP_DATA}/v2/stocks/bars", params=params)
        bars = j.get("bars", {})
        for k, arr in bars.items():
            out[k] = arr
    return out

async def bars_crypto(session: aiohttp.ClientSession, symbols: List[str], tf: str, lookback: int) -> Dict[str, List[Dict]]:
    """/v1beta3/crypto/us/bars ‚Äî —É Alpaca crypto endpoint —ñ–Ω—à–∏–π"""
    if not symbols:
        return {}
    out = {}
    end = dt.datetime.utcnow()
    start = end - dt.timedelta(minutes=lookback*5 if tf.endswith("Min") else lookback*60)
    params_template = {
        "timeframe": tf,
        "start": start.isoformat() + "Z",
        "end": end.isoformat() + "Z",
        "limit": lookback + 2,
    }
    for i in range(0, len(symbols), 50):
        syms = symbols[i:i+50]
        params = params_template | {"symbols": ",".join(syms)}
        j = await alp_get(session, f"{ALP_DATA}/v1beta3/crypto/us/bars", params=params)
        bars = j.get("bars", {})
        for k, arr in bars.items():
            out[k] = arr
    return out


# ==========================
# –û—Ü—ñ–Ω–∫–∞ —Å–∏–≥–Ω–∞–ª—É (–¥—É–∂–µ –ø—Ä–æ—Å—Ç–∞, –∞–ª–µ —à–≤–∏–¥–∫–∞)
# ==========================
def score_series(bars: List[Dict]) -> Tuple[float, float]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î (score, last_price).
    Score = –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ —Å—É–º–∞ –¥–≤–æ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç:
      1) –∞–ø-—Ç—Ä–µ–Ω–¥ (SMA(close, n1) < SMA(close, n2) < price)
      2) –º–æ–º–µ–Ω—Ç—É–º (pct_change –æ—Å—Ç–∞–Ω–Ω—ñ—Ö k –±–∞—Ä—ñ–≤)
    """
    if not bars or len(bars) < 10:
        return (0.0, 0.0)
    closes = [b["c"] for b in bars]
    p = closes[-1]
    n1, n2, k = 5, 20, 5
    if len(closes) < max(n2, k) + 1:
        return (0.0, p)
    sma1 = sum(closes[-n1:]) / n1
    sma2 = sum(closes[-n2:]) / n2
    mom = (closes[-1] / closes[-1-k]) - 1.0
    trend = 0.0
    if sma1 > sma2 and p > sma1:
        trend = 1.0
    # –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –º–æ–º–µ–Ω—Ç—É–º—É
    mom_norm = max(0.0, min(1.0, (mom - 0.0) / 0.03))  # ~3% –∑–∞ k –±–∞—Ä—ñ–≤ = –¥–æ–±—Ä–µ
    score = 0.55*trend + 0.45*mom_norm
    return (score, p)


# ==========================
# –°–∫–∞–Ω & –ø—ñ–¥–±—ñ—Ä
# ==========================
async def scan_universe(state: Dict) -> Tuple[List[Tuple[str,float,float,str]], str]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î picks = [(symbol, score, price, asset_class), ...] —Ç–∞ —Ç–µ–∫—Å—Ç –∑–≤—ñ—Ç—É.
    –ë–µ–∑ –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫ —Å–µ—Å—ñ—ó ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–∫–∞–Ω—É—î–º–æ –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω–µ.
    """
    profile = PROFILES[state["profile"]]
    tf = profile["tf"]
    lookback = profile["lookback"]
    min_score = profile["min_score"]

    wl_s = state.get("wl_stocks", []) or []
    wl_c = state.get("wl_crypto", []) or []

    async with aiohttp.ClientSession() as sess:
        # 1) –∞–∫—Ç–∏–≤–∏
        eq_all, cr_all = await alp_assets(sess)
        eq = wl_s if wl_s else eq_all
        cr = wl_c if wl_c else cr_all

        # 2) –±–∞—Ä–∏
        eq_bars = await bars_stocks(sess, eq, tf, lookback)
        cr_bars = await bars_crypto(sess, cr, tf, lookback)

    # 3) –æ—Ü—ñ–Ω—é–≤–∞–Ω–Ω—è
    picks: List[Tuple[str,float,float,str]] = []
    for sym, bars in eq_bars.items():
        sc, p = score_series(bars)
        if sc >= min_score and p > 0:
            picks.append((sym, sc, p, "equity"))
    for sym, bars in cr_bars.items():
        sc, p = score_series(bars)
        if sc >= min_score and p > 0:
            picks.append((sym, sc, p, "crypto"))

    # —Å–æ—Ä—Ç—É—î–º–æ –∑–∞ —Å–∫–æ—Ä–æ–º
    picks.sort(key=lambda x: x[1], reverse=True)

    # 4) —Ä–µ–ø–æ—Ä—Ç
    lines = [f"üîé –ü—Ä–æ—Ñ—ñ–ª—å: *{state['profile']}* ¬∑ TF=*{tf}* ¬∑ –ú—ñ–Ω.—Å–∫–æ—Ä={min_score}",
             f"–ê–∫—Ç–∏–≤—ñ–≤ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–æ: –∞–∫—Ü—ñ—ó {len(eq_bars)} ¬∑ –∫—Ä–∏–ø—Ç–æ {len(cr_bars)}",
             f"–ó–Ω–∞–π–¥–µ–Ω–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤: *{len(picks)}*",
             ""]
    for i, (sym, sc, p, cls) in enumerate(picks[:30], 1):
        lines.append(f"{i:>2}. `{sym}` ({cls}) ¬∑ score={sc:.2f} ¬∑ price={fmt_usd(p)}")
    rep = "\n".join(lines)
    return picks, rep


# ==========================
# –í–∏—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤
# ==========================
async def place_orders(state: Dict, chat_id: int, picks: List[Tuple[str,float,float,str]]):
    """–ú–∞—Ä–∫–µ—Ç-–æ—Ä–¥–µ—Ä–∞ –ø–æ top-n –∫–∞–Ω–¥–∏–¥–∞—Ç–∞—Ö (–ø–æ —Ñ–∞–∫—Ç—É ‚Äî –≤—Å—ñ, –ø–æ–∫–∏ –≤–∏—Å—Ç–∞—á–∞—î –∫–µ—à—É/–ø—Ä–∞–≤–∏–ª)."""
    if not state.get("autotrade", False):
        return "‚ÑπÔ∏è Autotrade –≤–∏–º–∫–Ω–µ–Ω–æ ‚Äî –æ—Ä–¥–µ—Ä–∏ –Ω–µ —Å—Ç–∞–≤–∏–º–æ."

    async with aiohttp.ClientSession() as sess:
        acc = await alp_account(sess)
        cash = float(acc.get("cash", 0.0))

        placed = []
        for sym, score, price, cls in picks:
            if cash < NOTIONAL:
                break
            # –ê–ª–ø–∞–∫–∞ –ø—Ä–∏–π–º–∞—î crypto —Å–∏–º–≤–æ–ª–∏ —É —Ñ–æ—Ä–º–∞—Ç—ñ BTC/USD —è–∫ —î
            order = {
                "symbol": sym,
                "notional": NOTIONAL,
                "side": "buy",
                "type": "market",
                "time_in_force": "day" if cls == "equity" else "gtc",
            }
            try:
                resp = await alp_post(sess, f"{ALP_BASE}/v2/orders", json=order)
                oid = resp.get("id", "?")
                placed.append(f"‚úÖ {sym} ({cls}) {fmt_usd(NOTIONAL)} ¬∑ id={oid}")
                cash -= NOTIONAL
            except Exception as e:
                placed.append(f"‚ùå {sym} ({cls}) ‚Äî {e}")

    txt = ["üõí –û—Ä–¥–µ—Ä–∏:"]
    txt.extend(placed if placed else ["(–Ω—ñ—á–æ–≥–æ –Ω–µ –≤–∏—Å—Ç–∞–≤–ª–µ–Ω–æ)"])
    return "\n".join(txt)


# ==========================
# Telegram UI
# ==========================
def kb_main() -> InlineKeyboardMarkup:
    rows = [
        [
            InlineKeyboardButton("Aggressive", callback_data="prof:aggressive"),
            InlineKeyboardButton("Scalp",      callback_data="prof:scalp"),
            InlineKeyboardButton("Default",    callback_data="prof:default"),
        ],
        [
            InlineKeyboardButton("Swing",      callback_data="prof:swing"),
            InlineKeyboardButton("Safe",       callback_data="prof:safe"),
        ],
        [
            InlineKeyboardButton("Signals",    callback_data="act:signals"),
            InlineKeyboardButton("Autotrade ON", callback_data="act:alp_on"),
            InlineKeyboardButton("Autotrade OFF", callback_data="act:alp_off"),
        ],
        [
            InlineKeyboardButton("Status",     callback_data="act:status"),
        ],
    ]
    return InlineKeyboardMarkup(rows)


# ==========================
# Handlers
# ==========================
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    txt = (
        "üëã –ì–æ—Ç–æ–≤–æ. –ë–æ—Ç —Å–∫–∞–Ω—É—î *–≤—Å—ñ* –¥–æ—Å—Ç—É–ø–Ω—ñ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –Ω–∞ Alpaca ‚Äî –∞–∫—Ü—ñ—ó —Ç–∞ –∫—Ä–∏–ø—Ç—É ‚Äî "
        "—Ç–∞ (–∑–∞ –±–∞–∂–∞–Ω–Ω—è–º) —Å—Ç–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä–∏.\n\n"
        "–ö–æ–º–∞–Ω–¥–∏:\n"
        "‚Ä¢ /alp_on /alp_off ‚Äî —É–≤—ñ–º–∫/–≤–∏–º–∫ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥\n"
        "‚Ä¢ /alp_status ‚Äî —Å—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É\n"
        "‚Ä¢ /signals_alpaca ‚Äî —Ä—É—á–Ω–∏–π —Å–∫–∞–Ω + (–∑–∞ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥—É) –æ—Ä–¥–µ—Ä–∏\n\n"
        "–ü—Ä–æ—Ñ—ñ–ª—å: */{p}*  ¬∑ Autotrade: *{a}*\nUTC {t}"
    ).format(p=st["profile"], a="ON" if st["autotrade"] else "OFF", t=now_utc())
    await u.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, reply_markup=kb_main())

async def alp_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = True
    await u.message.reply_text("‚úÖ Alpaca AUTOTRADE: ON")

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = False
    await u.message.reply_text("üü® Alpaca AUTOTRADE: OFF")

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    try:
        async with aiohttp.ClientSession() as sess:
            acc = await alp_account(sess)
        txt = (
            "üíº Alpaca: status=*{s}*\n‚Ä¢ cash={cash}\n‚Ä¢ buying_power={bp}\n‚Ä¢ equity={eq}"
        ).format(
            s=acc.get("status", "?"),
            cash=fmt_usd(float(acc.get("cash", 0.0))),
            bp=fmt_usd(float(acc.get("buying_power", 0.0))),
            eq=fmt_usd(float(acc.get("equity", 0.0))),
        )
    except Exception as e:
        txt = f"‚ùå Alpaca error: {e}"
    await u.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    try:
        picks, rep = await scan_universe(st)
        await u.message.reply_text(rep, parse_mode=ParseMode.MARKDOWN)

        # –ª–æ–≥ CSV (–∑–∞ –±–∞–∂–∞–Ω–Ω—è)
        if SIGLOG_PATH:
            rows = [["time","symbol","score","price","class"]]
            for sym, sc, p, cls in picks:
                rows.append([now_utc(), sym, f"{sc:.4f}", f"{p:.6f}", cls])
            with open(SIGLOG_PATH, "a", newline="", encoding="utf-8") as f:
                w = csv.writer(f); w.writerows(rows)

        if st.get("autotrade") and picks:
            # –≤—ñ–∑—å–º–µ–º–æ —Ç–æ–ø-5 –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
            orders_txt = await place_orders(st, u.effective_chat.id, picks[:5])
            await u.message.reply_text(orders_txt)
    except Exception as e:
        await u.message.reply_text(f"‚ùå scan error: {e}")

async def btn_cb(u: Update, c: ContextTypes.DEFAULT_TYPE):
    q = u.callback_query
    await q.answer()
    data = q.data or ""
    st = STATE.setdefault(u.effective_chat.id, default_state())

    try:
        if data.startswith("prof:"):
            prof = data.split(":",1)[1]
            if prof in PROFILES:
                st["profile"] = prof
                await q.edit_message_text(
                    f"‚úÖ –ü—Ä–æ—Ñ—ñ–ª—å –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: *{prof}*\n–ù–∞—Ç–∏—Å–Ω–∏ *Signals* –¥–ª—è —Å–∫–∞–Ω—É.",
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=kb_main(),
                )
            else:
                await q.edit_message_text("–ù–µ–≤—ñ–¥–æ–º–∏–π –ø—Ä–æ—Ñ—ñ–ª—å.", reply_markup=kb_main())
        elif data == "act:alp_on":
            st["autotrade"] = True
            await q.edit_message_text("‚úÖ Autotrade: ON", reply_markup=kb_main())
        elif data == "act:alp_off":
            st["autotrade"] = False
            await q.edit_message_text("üü® Autotrade: OFF", reply_markup=kb_main())
        elif data == "act:signals":
            picks, rep = await scan_universe(st)
            await c.bot.send_message(chat_id=u.effective_chat.id, text=rep, parse_mode=ParseMode.MARKDOWN)
            if st.get("autotrade") and picks:
                orders_txt = await place_orders(st, u.effective_chat.id, picks[:5])
                await c.bot.send_message(chat_id=u.effective_chat.id, text=orders_txt)
        elif data == "act:status":
            async with aiohttp.ClientSession() as sess:
                acc = await alp_account(sess)
            txt = (
                "üíº Alpaca: status=*{s}*\n‚Ä¢ cash={cash}\n‚Ä¢ buying_power={bp}\n‚Ä¢ equity={eq}"
            ).format(
                s=acc.get("status","?"),
                cash=fmt_usd(float(acc.get("cash",0.0))),
                bp=fmt_usd(float(acc.get("buying_power",0.0))),
                eq=fmt_usd(float(acc.get("equity",0.0))),
            )
            await c.bot.send_message(chat_id=u.effective_chat.id, text=txt, parse_mode=ParseMode.MARKDOWN)
        else:
            await q.edit_message_text("?", reply_markup=kb_main())
    except Exception as e:
        await c.bot.send_message(chat_id=u.effective_chat.id, text=f"‚ùå {e}")

# ==========================
# main
# ==========================
def ensure_env():
    miss = [k for k in ("TELEGRAM_BOT_TOKEN","ALPACA_API_KEY","ALPACA_API_SECRET") if not os.getenv(k)]
    if miss:
        raise RuntimeError(f"Missing env: {', '.join(miss)}")

async def run():
    ensure_env()
    app: Application = ApplicationBuilder().token(TG_TOKEN).build()
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", status_cmd))
    app.add_handler(CommandHandler("signals_alpaca", signals_cmd))
    app.add_handler(CallbackQueryHandler(btn_cb))
    await app.initialize()
    await app.start()
    await app.updater.start_polling(drop_pending_updates=True)
    # –±–µ–∑–∫—ñ–Ω–µ—á–Ω–æ
    await asyncio.Event().wait()

if __name__ == "__main__":
    asyncio.run(run())
