# bot.py
# 24/7 ProfitSignalsBot for Alpaca (stocks + crypto). No sessions, no whitelists.
# Requires: python-telegram-bot >= 21, aiohttp

import os, asyncio, math, json, time
from typing import Dict, Any, List, Tuple
import aiohttp
from datetime import datetime, timezone

from telegram import (
    Update, ReplyKeyboardMarkup, KeyboardButton, ParseMode,
)
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler, ContextTypes,
)

# ----------- ENV -------------
TG_TOKEN         = os.environ["TELEGRAM_BOT_TOKEN"]
APCA_KEY         = os.environ["ALPACA_API_KEY"]
APCA_SECRET      = os.environ["ALPACA_API_SECRET"]
APCA_TRADING_URL = os.environ.get("ALPACA_BASE_URL", "https://paper-api.alpaca.markets/v2")
APCA_DATA_URL    = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")

ALPACA_ENABLE    = int(os.environ.get("ALPACA_ENABLE", "1"))  # 1=on, 0=off
NOTIONAL_USD     = float(os.environ.get("ALPACA_NOTIONAL", "50"))
MAX_STOCKS       = int(os.environ.get("ALPACA_MAX_STOCKS", "150"))
MAX_CRYPTO       = int(os.environ.get("ALPACA_MAX_CRYPTO", "50"))
SCAN_EVERY_SEC   = int(os.environ.get("SCAN_EVERY_SEC", "120"))

# –ø—Ä–æ—Å—Ç—ñ —Ñ—ñ–ª—å—Ç—Ä–∏/–ø—Ä–æ—Ñ—ñ–ª—ñ (–º–æ–∂–Ω–∞ —Ä–æ–∑—à–∏—Ä—é–≤–∞—Ç–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏)
PROFILES = {
    "default": dict(min_change=0.02, max_spread=0.02, max_price=1000, min_dollar_vol=1_000_000),
    "aggressive": dict(min_change=0.01, max_spread=0.03, max_price=5000, min_dollar_vol=300_000),
    "scalp": dict(min_change=0.005, max_spread=0.01, max_price=1000, min_dollar_vol=2_000_000),
    "swing": dict(min_change=0.03, max_spread=0.03, max_price=1000, min_dollar_vol=800_000),
    "safe": dict(min_change=0.025, max_spread=0.015, max_price=1000, min_dollar_vol=2_500_000),
}

# ----------- STATE (in-memory) -------------
def default_state():
    return {
        "autotrade": False,
        "profile": "default",
        "last_report": "",
    }

STATE: Dict[int, Dict[str, Any]] = {}

def kb_main() -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton("/alp_on"), KeyboardButton("/alp_off"), KeyboardButton("/alp_status")],
        [KeyboardButton("/signals_alpaca")],
        [KeyboardButton("/default"), KeyboardButton("/aggressive"), KeyboardButton("/scalp")],
        [KeyboardButton("/swing"), KeyboardButton("/safe")],
        [KeyboardButton("/help")],
    ]
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# ----------- HTTP helpers -------------
def apca_auth_headers() -> Dict[str, str]:
    return {
        "APCA-API-KEY-ID": APCA_KEY,
        "APCA-API-SECRET-KEY": APCA_SECRET,
        "Content-Type": "application/json",
    }

async def http_get(session: aiohttp.ClientSession, url: str, params=None) -> Any:
    async with session.get(url, params=params, headers=apca_auth_headers(), timeout=30) as r:
        if r.status >= 400:
            text = await r.text()
            raise RuntimeError(f"GET {url} {r.status}: {text}")
        return await r.json()

async def http_post(session: aiohttp.ClientSession, url: str, payload: dict) -> Any:
    async with session.post(url, data=json.dumps(payload), headers=apca_auth_headers(), timeout=30) as r:
        if r.status >= 400:
            text = await r.text()
            raise RuntimeError(f"POST {url} {r.status}: {text}")
        return await r.json()

# ----------- Alpaca helpers -------------
async def alp_clock(session) -> Dict[str, Any]:
    # market clock (–¥–ª—è –∞–∫—Ü—ñ–π)
    url = f"{APCA_TRADING_URL}/clock"
    return await http_get(session, url)

async def alp_account(session) -> Dict[str, Any]:
    url = f"{APCA_TRADING_URL}/account"
    return await http_get(session, url)

async def list_assets(session, asset_class: str, limit: int) -> List[Dict[str, Any]]:
    # asset_class: "us_equity" | "crypto"
    url = f"{APCA_TRADING_URL}/assets"
    params = dict(status="active", asset_class=asset_class)
    assets = await http_get(session, url, params=params)
    # –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä—É—î–º–æ –ª–∏—à–µ tradable —ñ –±–µ–∑ OTC
    items = [a for a in assets if a.get("tradable") and not a.get("symbol","").startswith("OTC:")]
    return items[:limit]

def chunk(lst: List[Any], n: int) -> List[List[Any]]:
    return [lst[i:i+n] for i in range(0, len(lst), n)]

def fmt_usd(x: float) -> str:
    return f"${x:,.2f}"

def now_utc() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

# ---- Snapshots (—Ü—ñ–Ω–∏/–∑–º—ñ–Ω–∞) ----
async def stock_snapshots(session, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
    # /v2/stocks/snapshots?symbols=...
    res: Dict[str, Dict[str, Any]] = {}
    if not symbols:
        return res
    url = f"{APCA_DATA_URL}/v2/stocks/snapshots"
    for group in chunk(symbols, 100):  # API –¥–æ–∑–≤–æ–ª—è—î –ø–∞–∫–µ—Ç–Ω–æ
        data = await http_get(session, url, params={"symbols": ",".join(group)})
        snaps = data.get("snapshots", {})
        for sym, snap in snaps.items():
            last = (snap.get("latestTrade") or {}).get("p")
            prev = (snap.get("prevDailyBar") or {}).get("c")
            spread = 0.0
            book = snap.get("latestQuote") or {}
            ap, bp = book.get("ap"), book.get("bp")
            if ap and bp and ap > 0:
                spread = (ap - bp) / ap
            if last and prev and prev > 0:
                change = (last - prev) / prev
                dollar_vol = float(((snap.get("minuteBar") or {}).get("v") or 0.0)) * float(((snap.get("minuteBar") or {}).get("vw") or last))
                res[sym] = dict(price=last, prev=prev, change=change, spread=spread, dollar_vol=dollar_vol)
    return res

async def crypto_snapshots(session, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
    # /v1beta3/crypto/us/snapshots?symbols=BTC/USD,ETH/USD
    res: Dict[str, Dict[str, Any]] = {}
    if not symbols:
        return res
    url = f"{APCA_DATA_URL}/v1beta3/crypto/us/snapshots"
    for group in chunk(symbols, 50):
        data = await http_get(session, url, params={"symbols": ",".join(group)})
        snaps = data.get("snapshots", {})
        for sym, snap in snaps.items():
            last = (snap.get("latestTrade") or {}).get("p")
            prev = (snap.get("prevDailyBar") or {}).get("c")
            spread = 0.0
            book = snap.get("latestQuote") or {}
            ap, bp = book.get("ap"), book.get("bp")
            if ap and bp and ap > 0:
                spread = (ap - bp) / ap
            if last and prev and prev > 0:
                change = (last - prev) / prev
                # –ø—Ä–∏–±–ª–∏–∑–Ω–æ –æ—Ü—ñ–Ω–∏–º–æ –æ–±—ñ–≥
                dollar_vol = float(((snap.get("minuteBar") or {}).get("v") or 0.0)) * float(((snap.get("minuteBar") or {}).get("vw") or last))
                res[sym] = dict(price=last, prev=prev, change=change, spread=spread, dollar_vol=dollar_vol)
    return res

# ---- Strategy / scoring ----
def pick_symbols(profile: str, quotes: Dict[str, Dict[str, Any]], max_take: int) -> List[Tuple[str, Dict[str,Any]]]:
    p = PROFILES.get(profile, PROFILES["default"])
    min_change = float(p["min_change"])
    max_spread = float(p["max_spread"])
    max_price = float(p["max_price"])
    min_dvol = float(p["min_dollar_vol"])

    items = []
    for sym, q in quotes.items():
        if q["price"] > max_price: 
            continue
        if q["spread"] > max_spread:
            continue
        if q["dollar_vol"] < min_dvol:
            continue
        if abs(q["change"]) < min_change:
            continue
        score = abs(q["change"]) / max(0.0001, q["spread"] + 0.0005)
        items.append((sym, q | {"score": score}))
    items.sort(key=lambda x: x[1]["score"], reverse=True)
    return items[:max_take]

# ---- Orders ----
def to_crypto_symbol(sym: str) -> str:
    """
    –ü—Ä–∏–π–º–∞—î–º–æ BTCUSD/BTCUSDT/BTC-USD ‚Äî –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ –¥–æ —Ñ–æ—Ä–º–∞—Ç—É Alpaca: BTC/USD
    """
    s = sym.replace("-", "").replace("/", "").upper()
    if s.endswith("USDT"): s = s[:-4] + "USD"
    if not s.endswith("USD"): s = s + "USD"
    base = s[:-3]
    return f"{base}/USD"

async def place_order(session, symbol: str, side: str, asset_class: str, market_open: bool) -> Dict[str, Any]:
    # –î–ª—è –∞–∫—Ü—ñ–π ‚Äî —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Ä–∏–Ω–æ–∫ –≤—ñ–¥–∫—Ä–∏—Ç–∏–π; –¥–ª—è –∫—Ä–∏–ø—Ç–∏ ‚Äî –∑–∞–≤–∂–¥–∏
    tif = "day"
    payload = dict(
        symbol = symbol if asset_class=="us_equity" else to_crypto_symbol(symbol),
        side   = side,              # "buy" / "sell"
        type   = "market",
        time_in_force = tif,
        notional = NOTIONAL_USD,
    )
    if asset_class == "us_equity" and not market_open:
        # –Ω–µ —Å—Ç–∞–≤–∏–º–æ –∞–∫—Ü—ñ—ó –ø–æ–∑–∞ —Å–µ—Å—ñ—î—é, –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        return {"skipped":"market_closed"}
    url = f"{APCA_TRADING_URL}/orders"
    return await http_post(session, url, payload)

# ---- Scan-all ----
async def scan_all(state: Dict[str,Any]) -> Tuple[str, List[Tuple[str,dict]], List[Tuple[str,dict]]]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–µ–∫—Å—Ç–æ–≤–∏–π –∑–≤—ñ—Ç + –ø—ñ–∫–∏ –¥–ª—è –∞–∫—Ü—ñ–π —ñ –∫—Ä–∏–ø—Ç–∏.
    """
    profile = state.get("profile","default")
    async with aiohttp.ClientSession() as s:
        # —Å—Ç–∞—Ç—É—Å –∞–∫–∞—É–Ω—Ç—É —ñ –≥–æ–¥–∏–Ω–Ω–∏–∫
        try:
            acc = await alp_account(s)
            clk = await alp_clock(s)
            market_open = bool(clk.get("is_open"))
        except Exception:
            # —è–∫—â–æ –≥–æ–¥–∏–Ω–Ω–∏–∫ –Ω–µ –¥—ñ—Å—Ç–∞–≤—Å—è ‚Äî –ø—Ä–æ—Å—Ç–æ –≤–≤–∞–∂–∞—î–º–æ —Ä–∏–Ω–æ–∫ –∑–∞–∫—Ä–∏—Ç–∏–º
            market_open = False
            acc = {}

        # --- assets
        stocks = await list_assets(s, "us_equity", MAX_STOCKS)
        st_syms = [a["symbol"] for a in stocks]
        crypto = await list_assets(s, "crypto", MAX_CRYPTO)
        cr_syms = [a["symbol"] for a in crypto]
        # —É Alpaca crypto symbols –≤–∂–µ —É —Ñ–æ—Ä–º–∞—Ç—ñ "BTC/USD". –î–ª—è —Å–Ω–∞–ø—à–æ—Ç—ñ–≤ ‚Äî —Ç–∞–∫ —ñ –ª–∏—à–∞—î–º–æ.
        # –î–ª—è —É–Ω—ñ—Ñ—ñ–∫–∞—Ü—ñ—ó –∑—Ä–æ–±–∏–º–æ –±–µ–∑ —Å–ª–µ—à–∞ –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        cr_snaps_syms = cr_syms

        # --- quotes
        st_quotes = await stock_snapshots(s, st_syms)
        cr_quotes = await crypto_snapshots(s, cr_snaps_syms)

        # --- pick
        picks_st = pick_symbols(profile, st_quotes, max_take=20)
        picks_cr = pick_symbols(profile, cr_quotes, max_take=20)

        # --- report
        lines = []
        lines.append(f"üìä Scan ({profile}) ‚Ä¢ {now_utc()}")
        lines.append(f"Stocks scanned: {len(st_quotes)} ‚Ä¢ Crypto scanned: {len(cr_quotes)} ‚Ä¢ Market open: {market_open}")
        if picks_st:
            lines.append("\nüü¶ Top stocks:")
            for sym, q in picks_st[:10]:
                lines.append(f"‚Ä¢ {sym}: Œî {q['change']*100:.2f}% ‚Ä¢ spread {q['spread']*100:.2f}% ‚Ä¢ {fmt_usd(q['price'])}")
        if picks_cr:
            lines.append("\nüüß Top crypto:")
            for sym, q in picks_cr[:10]:
                lines.append(f"‚Ä¢ {sym}: Œî {q['change']*100:.2f}% ‚Ä¢ spread {q['spread']*100:.2f}% ‚Ä¢ {fmt_usd(q['price'])}")

        rep = "\n".join(lines)
        return rep, [(s,q) for s,q in picks_st], [(s,q) for s,q in picks_cr], market_open

# ---- Telegram commands ----
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    txt = (
        "üëã –ì–æ—Ç–æ–≤–æ. –ë–æ—Ç 24/7 —Å–∫–∞–Ω—É—î –∞–∫—Ü—ñ—ó —Ç–∞ –∫—Ä–∏–ø—Ç—É –π (–∑–∞ –±–∞–∂–∞–Ω–Ω—è–º) —Å—Ç–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä–∏ –≤ **Alpaca**.\n\n"
        "‚Ä¢ /alp_on ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥\n"
        "‚Ä¢ /alp_off ‚Äî –≤–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥\n"
        "‚Ä¢ /alp_status ‚Äî —Å—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É\n"
        "‚Ä¢ /signals_alpaca ‚Äî —Ä—É—á–Ω–∏–π —Å–∫–∞–Ω + (—è–∫—â–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥) –≤–∏—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤\n\n"
        "–ü—Ä–æ—Ñ—ñ–ª—ñ: /default /aggressive /scalp /swing /safe"
    )
    await u.message.reply_text(txt, reply_markup=kb_main(), parse_mode=ParseMode.MARKDOWN)

async def help_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    await start_cmd(u, c)

async def set_profile(u: Update, _: ContextTypes.DEFAULT_TYPE, name: str = "default"):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    if name not in PROFILES: name = "default"
    st["profile"] = name
    await u.message.reply_text(f"‚úÖ –ü—Ä–æ—Ñ—ñ–ª—å: {name}", reply_markup=kb_main())

async def alp_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = True
    await u.message.reply_text("‚úÖ Alpaca AUTOTRADE: ON", reply_markup=kb_main())

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = False
    await u.message.reply_text("‚èπ Alpaca AUTOTRADE: OFF", reply_markup=kb_main())

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    async with aiohttp.ClientSession() as s:
        try:
            acc = await alp_account(s)
            txt = ("üíº Alpaca: "
                   f"status={acc.get('status','?')} ¬∑ "
                   f"cash={fmt_usd(float(acc.get('cash',0)))} ¬∑ "
                   f"buying_power={fmt_usd(float(acc.get('buying_power',0)))} ¬∑ "
                   f"equity={fmt_usd(float(acc.get('equity',0)))}")
        except Exception as e:
            txt = f"‚ùå Alpaca error: {e}"
    await u.message.reply_text(txt)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    chat_id = u.effective_chat.id
    st = STATE.setdefault(chat_id, default_state())
    rep, picks_st, picks_cr, market_open = await scan_all(st)
    await u.message.reply_text(rep)

    if st.get("autotrade") and ALPACA_ENABLE:
        # –°—Ç–∞–≤–∏–º–æ –æ—Ä–¥–µ—Ä–∏: –∞–∫—Ü—ñ—ó ‚Äî —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ market_open; –∫—Ä–∏–ø—Ç–∞ ‚Äî –∑–∞–≤–∂–¥–∏
        placed = []
        async with aiohttp.ClientSession() as s:
            for sym, q in picks_cr[:3]:
                try:
                    r = await place_order(s, sym, "buy", "crypto", market_open=True)
                    if "id" in r:
                        placed.append(f"üüß CRYPTO BUY {sym} {fmt_usd(NOTIONAL_USD)} ‚úì")
                except Exception as e:
                    placed.append(f"üüß CRYPTO BUY {sym} ERR: {e}")
            if market_open:
                for sym, q in picks_st[:3]:
                    try:
                        r = await place_order(s, sym, "buy", "us_equity", market_open=True)
                        if "id" in r:
                            placed.append(f"üü¶ STOCK BUY {sym} {fmt_usd(NOTIONAL_USD)} ‚úì")
                    except Exception as e:
                        placed.append(f"üü¶ STOCK BUY {sym} ERR: {e}")
        if placed:
            await u.message.reply_text("\n".join(placed))

# ---- Periodic autoscan for chats with autotrade ON ----
async def autoscan_loop(app: Application):
    await asyncio.sleep(5)
    while True:
        try:
            if STATE:
                for chat_id, st in list(STATE.items()):
                    if st.get("autotrade") and ALPACA_ENABLE:
                        rep, picks_st, picks_cr, market_open = await scan_all(st)
                        # –ù–µ –∑–∞—Å–º—ñ—á—É—î–º–æ —á–∞—Ç ‚Äî –∫–æ—Ä–æ—Ç–∫–∏–π –¥–∞–π–¥–∂–µ—Å—Ç
                        msg = f"‚è± Auto-scan {now_utc()} ‚Ä¢ stocks {len(picks_st)} ‚Ä¢ crypto {len(picks_cr)}"
                        try:
                            await app.bot.sendMessage(chat_id=chat_id, text=msg)
                        except Exception:
                            pass
                        # –ê–≤—Ç–æ–æ—Ä–¥–µ—Ä–∞
                        async with aiohttp.ClientSession() as s:
                            placed = []
                            for sym, q in picks_cr[:1]:
                                try:
                                    r = await place_order(s, sym, "buy", "crypto", market_open=True)
                                    if "id" in r:
                                        placed.append(f"CRYPTO BUY {sym} {fmt_usd(NOTIONAL_USD)} ‚úì")
                                except Exception: pass
                            if market_open:
                                for sym, q in picks_st[:1]:
                                    try:
                                        r = await place_order(s, sym, "buy", "us_equity", market_open=True)
                                        if "id" in r:
                                            placed.append(f"STOCK BUY {sym} {fmt_usd(NOTIONAL_USD)} ‚úì")
                                    except Exception: pass
                            if placed:
                                try:
                                    await app.bot.sendMessage(chat_id=chat_id, text="‚Ä¢ " + "\n‚Ä¢ ".join(placed))
                                except Exception:
                                    pass
        except Exception:
            # –Ω—ñ–∫–æ–ª–∏ –Ω–µ –ø–∞–¥–∞—Ç–∏ –∑ —Ü–∏–∫–ª—É
            pass
        await asyncio.sleep(SCAN_EVERY_SEC)

# ---- main ----
def run():
    app = ApplicationBuilder().token(TG_TOKEN).build()

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", status_cmd))
    app.add_handler(CommandHandler("signals_alpaca", signals_cmd))

    # –ø—Ä–æ—Ñ—ñ–ª—ñ
    app.add_handler(CommandHandler("default", lambda u,c: asyncio.create_task(set_profile(u,c,"default"))))
    app.add_handler(CommandHandler("aggressive", lambda u,c: asyncio.create_task(set_profile(u,c,"aggressive"))))
    app.add_handler(CommandHandler("scalp", lambda u,c: asyncio.create_task(set_profile(u,c,"scalp"))))
    app.add_handler(CommandHandler("swing", lambda u,c: asyncio.create_task(set_profile(u,c,"swing"))))
    app.add_handler(CommandHandler("safe", lambda u,c: asyncio.create_task(set_profile(u,c,"safe"))))

    # —Ñ–æ–Ω–æ–≤–∏–π –∞–≤—Ç–æ—Å–∫–∞–Ω
    app.post_init = lambda _: asyncio.create_task(autoscan_loop(app))

    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    run()
