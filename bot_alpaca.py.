# bot.py
# 24/7 ProfitSignalsBot for Alpaca (stocks + crypto). No sessions, no whitelists.
# Requires: python-telegram-bot >= 21, aiohttp

import os, asyncio, math, json, time
from typing import Dict, Any, List, Tuple
import aiohttp
from datetime import datetime, timezone

from telegram import (
    Update, ReplyKeyboardMarkup, KeyboardButton, ParseMode,
)
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler, ContextTypes,
)

# ----------- ENV -------------
TG_TOKEN         = os.environ["TELEGRAM_BOT_TOKEN"]
APCA_KEY         = os.environ["ALPACA_API_KEY"]
APCA_SECRET      = os.environ["ALPACA_API_SECRET"]
APCA_TRADING_URL = os.environ.get("ALPACA_BASE_URL", "https://paper-api.alpaca.markets/v2")
APCA_DATA_URL    = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")

ALPACA_ENABLE    = int(os.environ.get("ALPACA_ENABLE", "1"))  # 1=on, 0=off
NOTIONAL_USD     = float(os.environ.get("ALPACA_NOTIONAL", "50"))
MAX_STOCKS       = int(os.environ.get("ALPACA_MAX_STOCKS", "150"))
MAX_CRYPTO       = int(os.environ.get("ALPACA_MAX_CRYPTO", "50"))
SCAN_EVERY_SEC   = int(os.environ.get("SCAN_EVERY_SEC", "120"))

# прості фільтри/профілі (можна розширювати командами)
PROFILES = {
    "default": dict(min_change=0.02, max_spread=0.02, max_price=1000, min_dollar_vol=1_000_000),
    "aggressive": dict(min_change=0.01, max_spread=0.03, max_price=5000, min_dollar_vol=300_000),
    "scalp": dict(min_change=0.005, max_spread=0.01, max_price=1000, min_dollar_vol=2_000_000),
    "swing": dict(min_change=0.03, max_spread=0.03, max_price=1000, min_dollar_vol=800_000),
    "safe": dict(min_change=0.025, max_spread=0.015, max_price=1000, min_dollar_vol=2_500_000),
}

# ----------- STATE (in-memory) -------------
def default_state():
    return {
        "autotrade": False,
        "profile": "default",
        "last_report": "",
    }

STATE: Dict[int, Dict[str, Any]] = {}

def kb_main() -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton("/alp_on"), KeyboardButton("/alp_off"), KeyboardButton("/alp_status")],
        [KeyboardButton("/signals_alpaca")],
        [KeyboardButton("/default"), KeyboardButton("/aggressive"), KeyboardButton("/scalp")],
        [KeyboardButton("/swing"), KeyboardButton("/safe")],
        [KeyboardButton("/help")],
    ]
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# ----------- HTTP helpers -------------
def apca_auth_headers() -> Dict[str, str]:
    return {
        "APCA-API-KEY-ID": APCA_KEY,
        "APCA-API-SECRET-KEY": APCA_SECRET,
        "Content-Type": "application/json",
    }

async def http_get(session: aiohttp.ClientSession, url: str, params=None) -> Any:
    async with session.get(url, params=params, headers=apca_auth_headers(), timeout=30) as r:
        if r.status >= 400:
            text = await r.text()
            raise RuntimeError(f"GET {url} {r.status}: {text}")
        return await r.json()

async def http_post(session: aiohttp.ClientSession, url: str, payload: dict) -> Any:
    async with session.post(url, data=json.dumps(payload), headers=apca_auth_headers(), timeout=30) as r:
        if r.status >= 400:
            text = await r.text()
            raise RuntimeError(f"POST {url} {r.status}: {text}")
        return await r.json()

# ----------- Alpaca helpers -------------
async def alp_clock(session) -> Dict[str, Any]:
    # market clock (для акцій)
    url = f"{APCA_TRADING_URL}/clock"
    return await http_get(session, url)

async def alp_account(session) -> Dict[str, Any]:
    url = f"{APCA_TRADING_URL}/account"
    return await http_get(session, url)

async def list_assets(session, asset_class: str, limit: int) -> List[Dict[str, Any]]:
    # asset_class: "us_equity" | "crypto"
    url = f"{APCA_TRADING_URL}/assets"
    params = dict(status="active", asset_class=asset_class)
    assets = await http_get(session, url, params=params)
    # відфільтруємо лише tradable і без OTC
    items = [a for a in assets if a.get("tradable") and not a.get("symbol","").startswith("OTC:")]
    return items[:limit]

def chunk(lst: List[Any], n: int) -> List[List[Any]]:
    return [lst[i:i+n] for i in range(0, len(lst), n)]

def fmt_usd(x: float) -> str:
    return f"${x:,.2f}"

def now_utc() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

# ---- Snapshots (ціни/зміна) ----
async def stock_snapshots(session, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
    # /v2/stocks/snapshots?symbols=...
    res: Dict[str, Dict[str, Any]] = {}
    if not symbols:
        return res
    url = f"{APCA_DATA_URL}/v2/stocks/snapshots"
    for group in chunk(symbols, 100):  # API дозволяє пакетно
        data = await http_get(session, url, params={"symbols": ",".join(group)})
        snaps = data.get("snapshots", {})
        for sym, snap in snaps.items():
            last = (snap.get("latestTrade") or {}).get("p")
            prev = (snap.get("prevDailyBar") or {}).get("c")
            spread = 0.0
            book = snap.get("latestQuote") or {}
            ap, bp = book.get("ap"), book.get("bp")
            if ap and bp and ap > 0:
                spread = (ap - bp) / ap
            if last and prev and prev > 0:
                change = (last - prev) / prev
                dollar_vol = float(((snap.get("minuteBar") or {}).get("v") or 0.0)) * float(((snap.get("minuteBar") or {}).get("vw") or last))
                res[sym] = dict(price=last, prev=prev, change=change, spread=spread, dollar_vol=dollar_vol)
    return res

async def crypto_snapshots(session, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
    # /v1beta3/crypto/us/snapshots?symbols=BTC/USD,ETH/USD
    res: Dict[str, Dict[str, Any]] = {}
    if not symbols:
        return res
    url = f"{APCA_DATA_URL}/v1beta3/crypto/us/snapshots"
    for group in chunk(symbols, 50):
        data = await http_get(session, url, params={"symbols": ",".join(group)})
        snaps = data.get("snapshots", {})
        for sym, snap in snaps.items():
            last = (snap.get("latestTrade") or {}).get("p")
            prev = (snap.get("prevDailyBar") or {}).get("c")
            spread = 0.0
            book = snap.get("latestQuote") or {}
            ap, bp = book.get("ap"), book.get("bp")
            if ap and bp and ap > 0:
                spread = (ap - bp) / ap
            if last and prev and prev > 0:
                change = (last - prev) / prev
                # приблизно оцінимо обіг
                dollar_vol = float(((snap.get("minuteBar") or {}).get("v") or 0.0)) * float(((snap.get("minuteBar") or {}).get("vw") or last))
                res[sym] = dict(price=last, prev=prev, change=change, spread=spread, dollar_vol=dollar_vol)
    return res

# ---- Strategy / scoring ----
def pick_symbols(profile: str, quotes: Dict[str, Dict[str, Any]], max_take: int) -> List[Tuple[str, Dict[str,Any]]]:
    p = PROFILES.get(profile, PROFILES["default"])
    min_change = float(p["min_change"])
    max_spread = float(p["max_spread"])
    max_price = float(p["max_price"])
    min_dvol = float(p["min_dollar_vol"])

    items = []
    for sym, q in quotes.items():
        if q["price"] > max_price: 
            continue
        if q["spread"] > max_spread:
            continue
        if q["dollar_vol"] < min_dvol:
            continue
        if abs(q["change"]) < min_change:
            continue
        score = abs(q["change"]) / max(0.0001, q["spread"] + 0.0005)
        items.append((sym, q | {"score": score}))
    items.sort(key=lambda x: x[1]["score"], reverse=True)
    return items[:max_take]

# ---- Orders ----
def to_crypto_symbol(sym: str) -> str:
    """
    Приймаємо BTCUSD/BTCUSDT/BTC-USD — перетворюємо до формату Alpaca: BTC/USD
    """
    s = sym.replace("-", "").replace("/", "").upper()
    if s.endswith("USDT"): s = s[:-4] + "USD"
    if not s.endswith("USD"): s = s + "USD"
    base = s[:-3]
    return f"{base}/USD"

async def place_order(session, symbol: str, side: str, asset_class: str, market_open: bool) -> Dict[str, Any]:
    # Для акцій — тільки коли ринок відкритий; для крипти — завжди
    tif = "day"
    payload = dict(
        symbol = symbol if asset_class=="us_equity" else to_crypto_symbol(symbol),
        side   = side,              # "buy" / "sell"
        type   = "market",
        time_in_force = tif,
        notional = NOTIONAL_USD,
    )
    if asset_class == "us_equity" and not market_open:
        # не ставимо акції поза сесією, повертаємо повідомлення
        return {"skipped":"market_closed"}
    url = f"{APCA_TRADING_URL}/orders"
    return await http_post(session, url, payload)

# ---- Scan-all ----
async def scan_all(state: Dict[str,Any]) -> Tuple[str, List[Tuple[str,dict]], List[Tuple[str,dict]]]:
    """
    Повертає текстовий звіт + піки для акцій і крипти.
    """
    profile = state.get("profile","default")
    async with aiohttp.ClientSession() as s:
        # статус акаунту і годинник
        try:
            acc = await alp_account(s)
            clk = await alp_clock(s)
            market_open = bool(clk.get("is_open"))
        except Exception:
            # якщо годинник не дістався — просто вважаємо ринок закритим
            market_open = False
            acc = {}

        # --- assets
        stocks = await list_assets(s, "us_equity", MAX_STOCKS)
        st_syms = [a["symbol"] for a in stocks]
        crypto = await list_assets(s, "crypto", MAX_CRYPTO)
        cr_syms = [a["symbol"] for a in crypto]
        # у Alpaca crypto symbols вже у форматі "BTC/USD". Для снапшотів — так і лишаємо.
        # Для уніфікації зробимо без слеша для відображення
        cr_snaps_syms = cr_syms

        # --- quotes
        st_quotes = await stock_snapshots(s, st_syms)
        cr_quotes = await crypto_snapshots(s, cr_snaps_syms)

        # --- pick
        picks_st = pick_symbols(profile, st_quotes, max_take=20)
        picks_cr = pick_symbols(profile, cr_quotes, max_take=20)

        # --- report
        lines = []
        lines.append(f"📊 Scan ({profile}) • {now_utc()}")
        lines.append(f"Stocks scanned: {len(st_quotes)} • Crypto scanned: {len(cr_quotes)} • Market open: {market_open}")
        if picks_st:
            lines.append("\n🟦 Top stocks:")
            for sym, q in picks_st[:10]:
                lines.append(f"• {sym}: Δ {q['change']*100:.2f}% • spread {q['spread']*100:.2f}% • {fmt_usd(q['price'])}")
        if picks_cr:
            lines.append("\n🟧 Top crypto:")
            for sym, q in picks_cr[:10]:
                lines.append(f"• {sym}: Δ {q['change']*100:.2f}% • spread {q['spread']*100:.2f}% • {fmt_usd(q['price'])}")

        rep = "\n".join(lines)
        return rep, [(s,q) for s,q in picks_st], [(s,q) for s,q in picks_cr], market_open

# ---- Telegram commands ----
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    txt = (
        "👋 Готово. Бот 24/7 сканує акції та крипту й (за бажанням) ставить ордери в **Alpaca**.\n\n"
        "• /alp_on — увімкнути автотрейд\n"
        "• /alp_off — вимкнути автотрейд\n"
        "• /alp_status — стан акаунту\n"
        "• /signals_alpaca — ручний скан + (якщо автотрейд) виставлення ордерів\n\n"
        "Профілі: /default /aggressive /scalp /swing /safe"
    )
    await u.message.reply_text(txt, reply_markup=kb_main(), parse_mode=ParseMode.MARKDOWN)

async def help_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    await start_cmd(u, c)

async def set_profile(u: Update, _: ContextTypes.DEFAULT_TYPE, name: str = "default"):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    if name not in PROFILES: name = "default"
    st["profile"] = name
    await u.message.reply_text(f"✅ Профіль: {name}", reply_markup=kb_main())

async def alp_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = True
    await u.message.reply_text("✅ Alpaca AUTOTRADE: ON", reply_markup=kb_main())

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = False
    await u.message.reply_text("⏹ Alpaca AUTOTRADE: OFF", reply_markup=kb_main())

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    async with aiohttp.ClientSession() as s:
        try:
            acc = await alp_account(s)
            txt = ("💼 Alpaca: "
                   f"status={acc.get('status','?')} · "
                   f"cash={fmt_usd(float(acc.get('cash',0)))} · "
                   f"buying_power={fmt_usd(float(acc.get('buying_power',0)))} · "
                   f"equity={fmt_usd(float(acc.get('equity',0)))}")
        except Exception as e:
            txt = f"❌ Alpaca error: {e}"
    await u.message.reply_text(txt)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    chat_id = u.effective_chat.id
    st = STATE.setdefault(chat_id, default_state())
    rep, picks_st, picks_cr, market_open = await scan_all(st)
    await u.message.reply_text(rep)

    if st.get("autotrade") and ALPACA_ENABLE:
        # Ставимо ордери: акції — тільки якщо market_open; крипта — завжди
        placed = []
        async with aiohttp.ClientSession() as s:
            for sym, q in picks_cr[:3]:
                try:
                    r = await place_order(s, sym, "buy", "crypto", market_open=True)
                    if "id" in r:
                        placed.append(f"🟧 CRYPTO BUY {sym} {fmt_usd(NOTIONAL_USD)} ✓")
                except Exception as e:
                    placed.append(f"🟧 CRYPTO BUY {sym} ERR: {e}")
            if market_open:
                for sym, q in picks_st[:3]:
                    try:
                        r = await place_order(s, sym, "buy", "us_equity", market_open=True)
                        if "id" in r:
                            placed.append(f"🟦 STOCK BUY {sym} {fmt_usd(NOTIONAL_USD)} ✓")
                    except Exception as e:
                        placed.append(f"🟦 STOCK BUY {sym} ERR: {e}")
        if placed:
            await u.message.reply_text("\n".join(placed))

# ---- Periodic autoscan for chats with autotrade ON ----
async def autoscan_loop(app: Application):
    await asyncio.sleep(5)
    while True:
        try:
            if STATE:
                for chat_id, st in list(STATE.items()):
                    if st.get("autotrade") and ALPACA_ENABLE:
                        rep, picks_st, picks_cr, market_open = await scan_all(st)
                        # Не засмічуємо чат — короткий дайджест
                        msg = f"⏱ Auto-scan {now_utc()} • stocks {len(picks_st)} • crypto {len(picks_cr)}"
                        try:
                            await app.bot.sendMessage(chat_id=chat_id, text=msg)
                        except Exception:
                            pass
                        # Автоордера
                        async with aiohttp.ClientSession() as s:
                            placed = []
                            for sym, q in picks_cr[:1]:
                                try:
                                    r = await place_order(s, sym, "buy", "crypto", market_open=True)
                                    if "id" in r:
                                        placed.append(f"CRYPTO BUY {sym} {fmt_usd(NOTIONAL_USD)} ✓")
                                except Exception: pass
                            if market_open:
                                for sym, q in picks_st[:1]:
                                    try:
                                        r = await place_order(s, sym, "buy", "us_equity", market_open=True)
                                        if "id" in r:
                                            placed.append(f"STOCK BUY {sym} {fmt_usd(NOTIONAL_USD)} ✓")
                                    except Exception: pass
                            if placed:
                                try:
                                    await app.bot.sendMessage(chat_id=chat_id, text="• " + "\n• ".join(placed))
                                except Exception:
                                    pass
        except Exception:
            # ніколи не падати з циклу
            pass
        await asyncio.sleep(SCAN_EVERY_SEC)

# ---- main ----
def run():
    app = ApplicationBuilder().token(TG_TOKEN).build()

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", status_cmd))
    app.add_handler(CommandHandler("signals_alpaca", signals_cmd))

    # профілі
    app.add_handler(CommandHandler("default", lambda u,c: asyncio.create_task(set_profile(u,c,"default"))))
    app.add_handler(CommandHandler("aggressive", lambda u,c: asyncio.create_task(set_profile(u,c,"aggressive"))))
    app.add_handler(CommandHandler("scalp", lambda u,c: asyncio.create_task(set_profile(u,c,"scalp"))))
    app.add_handler(CommandHandler("swing", lambda u,c: asyncio.create_task(set_profile(u,c,"swing"))))
    app.add_handler(CommandHandler("safe", lambda u,c: asyncio.create_task(set_profile(u,c,"safe"))))

    # фоновий автоскан
    app.post_init = lambda _: asyncio.create_task(autoscan_loop(app))

    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    run()
