# bot_alpaca.py
# Telegram ‚Üí Alpaca (USD only): crypto + US stocks smart autotrade
# - –°–∫–∞–Ω—É—î –í–°–Ü –¥–æ—Å—Ç—É–ø–Ω—ñ –∞–∫—Ç–∏–≤–∏ –≤ Alpaca (–±–µ–∑ whitelist)
# - –î–≤–∞ —Ä–µ–∂–∏–º–∏: /mode_aggr (—à–≤–∏–¥—à–∏–π) —ñ /mode_safe (–Ω–∞–¥—ñ–π–Ω—ñ—à–∏–π)
# - /alp_on -> —Å—Ç–∞–≤–∏—Ç—å MARKET notional –∑ bracket TP/SL (ATR)
# - –Ø–∫—â–æ —Ä–∏–Ω–æ–∫ –∞–∫—Ü—ñ–π –∑–∞–∫—Ä–∏—Ç–∏–π ‚Äî —Ç–æ—Ä–≥—É—î —Ç—ñ–ª—å–∫–∏ –∫—Ä–∏–ø—Ç—É; —è–∫—â–æ –≤—ñ–¥–∫—Ä–∏—Ç–∏–π ‚Äî —Ç–æ—Ä–≥—É—î –æ–±–∏–¥–≤–∞
# - –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞: /signals /alp_on /alp_off /alp_status /mode_aggr /mode_safe /set_top /set_notional
#
# –ü–æ—Ç—Ä—ñ–±–Ω—ñ ENV:
# TELEGRAM_BOT_TOKEN=...
# ALPACA_API_KEY=...
# ALPACA_API_SECRET=...
# ALPACA_BASE_URL=https://paper-api.alpaca.markets/v2
# ALPACA_DATA_URL=https://data.alpaca.markets
# ALPACA_NOTIONAL=25
# ALPACA_TOP_N=5
# ALPACA_MAX_STOCKS=500
# ALPACA_MAX_CRYPTO=200

import os
import csv
import html
import asyncio
import aiohttp
import logging
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timezone

from telegram import Update, ReplyKeyboardMarkup, BotCommand
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes

# ================= ENV =================
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()

ALP_KEY   = os.getenv("ALPACA_API_KEY", "").strip()
ALP_SECRET= os.getenv("ALPACA_API_SECRET", "").strip()
ALP_BASE  = (os.getenv("ALPACA_BASE_URL") or "https://paper-api.alpaca.markets/v2").strip()
ALP_DATA  = (os.getenv("ALPACA_DATA_URL") or "https://data.alpaca.markets").strip()

TOP_N     = int(os.getenv("ALPACA_TOP_N", "5"))
NOTIONAL  = float(os.getenv("ALPACA_NOTIONAL", "25"))
MAX_STOCKS= int(os.getenv("ALPACA_MAX_STOCKS", "500"))
MAX_CRYPTO= int(os.getenv("ALPACA_MAX_CRYPTO", "200"))

LOG_PATH  = os.getenv("SIGLOG_PATH", "signals_log.csv")

# ================= LOGS ================
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
log = logging.getLogger("alpaca")

# ================= UI ==================
def _kb(st) -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        [
            ["/signals", "/alp_status"],
            ["/alp_on", "/alp_off"],
            ["/mode_aggr", "/mode_safe"],
            ["/set_top 10", "/set_notional 50"]
        ],
        resize_keyboard=True
    )

# ================= STATE ===============
STATE: Dict[int, Dict[str, object]] = {}

def utc_now_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")

def default_state() -> Dict[str, object]:
    return {
        "alp_on": False,
        "mode": "safe",           # 'aggr' | 'safe'
        "top_n": TOP_N,
        "notional": NOTIONAL,
        # —Ñ—ñ–ª—å—Ç—Ä–∏ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º (safe)
        "filters": {
            "min_adx": 14,        # –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —Ç—Ä–µ–Ω–¥–æ–≤–∏–π —ñ–º–ø—É–ª—å—Å
            "sl_k": 1.3,          # SL = sl_k √ó ATR
            "rr_k": 2.2,          # TP = rr_k √ó R
            "min_atr_pct": 0.8,   # ATR% >= ...
            "vol_mult": 1.0       # vol_15m > SMA20 √ó vol_mult
        },
        # –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π (aggr)
        "filters_aggr": {
            "min_adx": 10,
            "sl_k": 1.2,
            "rr_k": 2.0,
            "min_atr_pct": 0.6,
            "vol_mult": 1.0
        }
    }

# ================= INDICATORS ==========
def ema(xs: List[float], p: int) -> List[float]:
    if not xs: return []
    k = 2/(p+1.0); out=[xs[0]]
    for x in xs[1:]:
        out.append(out[-1] + k*(x - out[-1]))
    return out

def sma_series(xs: List[float], p: int) -> List[Optional[float]]:
    if p<=0: return []
    if len(xs)<p: return [None]*(p-1)
    out=[None]*(p-1)
    s=sum(xs[:p]); out.append(s/p)
    for i in range(p, len(xs)):
        s += xs[i]-xs[i-p]
        out.append(s/p)
    return out

def rsi(xs: List[float], p: int = 14) -> List[float]:
    if len(xs) < p+1: return []
    gains, losses = [], []
    for i in range(1, len(xs)):
        d = xs[i]-xs[i-1]
        gains.append(max(0,d)); losses.append(max(0,-d))
    ag = sum(gains[:p])/p; al = sum(losses[:p])/p
    out=[0.0]*p; out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    for i in range(p, len(gains)):
        ag=(ag*(p-1)+gains[i])/p; al=(al*(p-1)+losses[i])/p
        out.append(100.0 if al==0 else 100-100/(1+ag/(al+1e-9)))
    return out

def macd(xs: List[float], fast=12, slow=26, signal=9) -> Tuple[List[float], List[float]]:
    if len(xs) < slow+signal: return [], []
    ef, es = ema(xs, fast), ema(xs, slow)
    m=[a-b for a,b in zip(ef[-len(es):], es)]; s=ema(m, signal)
    L=min(len(m),len(s)); return m[-L:], s[-L:]

def atr_value(h: List[float], l: List[float], c: List[float], n: int=14) -> float:
    if len(c) < n+1 or not (len(h)==len(l)==len(c)): return 0.0
    trs=[]
    for i in range(1,len(c)):
        trs.append(max(h[i]-l[i], abs(h[i]-c[i-1]), abs(l[i]-c[i-1])))
    if len(trs)<n: return 0.0
    return sum(trs[-n:])/n

def adx_last(high: List[float], low: List[float], close: List[float], n: int=14) -> float:
    if len(close) < n+1: return 0.0
    plus_dm=[]; minus_dm=[]; tr=[]
    for i in range(1,len(close)):
        up = high[i]-high[i-1]; dn = low[i-1]-low[i]
        plus_dm.append(up if (up>dn and up>0) else 0.0)
        minus_dm.append(dn if (dn>up and dn>0) else 0.0)
        tr.append(max(high[i]-low[i], abs(high[i]-close[i-1]), abs(low[i]-close[i-1])))
    def rmean(xs: List[float], p: int) -> List[float]:
        if len(xs)<p: return []
        out=[]; s=sum(xs[:p]); out.append(s/p)
        for i in range(p, len(xs)):
            s += xs[i]-xs[i-p]; out.append(s/p)
        return out
    atr_n = rmean(tr, n)
    if not atr_n: return 0.0
    last = len(atr_n)-1; atrv = atr_n[last] or 1e-9
    pdi = 100.0 * (sum(plus_dm[-n:])/n) / atrv
    mdi = 100.0 * (sum(minus_dm[-n:])/n) / atrv
    dx = 100.0 * abs(pdi-mdi) / (pdi+mdi+1e-9)
    dx_series = rmean([dx]*n, n)
    return dx_series[-1] if dx_series else dx

# ================= HTTP =================
def alp_headers() -> dict:
    return {"APCA-API-KEY-ID": ALP_KEY, "APCA-API-SECRET-KEY": ALP_SECRET, "Content-Type":"application/json"}

async def http_json(session: aiohttp.ClientSession, url: str, params: dict=None, headers: dict=None, method: str="GET", payload: dict=None, timeout: int=30) -> dict:
    for attempt in range(4):
        try:
            if method=="GET":
                async with session.get(url, params=params, headers=headers, timeout=timeout) as r:
                    if r.status>=400:
                        raise RuntimeError(await r.text())
                    return await r.json()
            else:
                async with session.post(url, json=payload, headers=headers, timeout=timeout) as r:
                    if r.status>=400:
                        raise RuntimeError(await r.text())
                    return await r.json()
        except Exception as e:
            if attempt==3: raise
            await asyncio.sleep(0.6*(1.6**attempt))

# ======= Alpaca endpoints (account/clock/assets/orders) ========
async def alp_clock(session) -> dict:
    return await http_json(session, f"{ALP_BASE}/clock", headers=alp_headers())

async def alp_assets(session, asset_class: str) -> List[dict]:
    params={"status":"active", "tradable":"true", "asset_class": asset_class}
    return await http_json(session, f"{ALP_BASE}/assets", params=params, headers=alp_headers())

async def alp_place_order(session, payload: dict) -> dict:
    return await http_json(session, f"{ALP_BASE}/orders", headers=alp_headers(), method="POST", payload=payload)

# ============== DATA API (bars/quotes) ===============
async def bars_stocks(session, symbol: str, tf: str, limit: int=300):
    url=f"{ALP_DATA}/v2/stocks/bars"
    js = await http_json(session, url, params={"symbols":symbol,"timeframe":tf,"limit":str(limit)}, headers=alp_headers())
    series = ((js.get("bars") or {}).get(symbol) or [])
    O,H,L,C,V=[],[],[],[],[]
    for b in series[-limit:]:
        O.append(float(b.get("o",0))); H.append(float(b.get("h",0))); L.append(float(b.get("l",0)))
        C.append(float(b.get("c",0))); V.append(float(b.get("v",0)))
    return O,H,L,C,V

async def bars_crypto(session, symbol: str, tf: str, limit: int=300):
    # v2 crypto bars (symbols like BTCUSD, ETHUSD)
    url=f"{ALP_DATA}/v2/crypto/bars"
    js = await http_json(session, url, params={"symbols":symbol,"timeframe":tf,"limit":str(limit)}, headers=alp_headers())
    series = ((js.get("bars") or {}).get(symbol) or [])
    O,H,L,C,V=[],[],[],[],[]
    for b in series[-limit:]:
        O.append(float(b.get("o",0))); H.append(float(b.get("h",0))); L.append(float(b.get("l",0)))
        C.append(float(b.get("c",0))); V.append(float(b.get("v",0)))
    return O,H,L,C,V

async def spread_bps(session, symbol: str, asset_class: str) -> float:
    try:
        if asset_class=="stocks":
            url=f"{ALP_DATA}/v2/stocks/quotes/latest"
            js=await http_json(session, url, params={"symbol":symbol}, headers=alp_headers())
            q=js.get("quote") or {}
            bp=float(q.get("bp",0)); ap=float(q.get("ap",0))
        else:
            url=f"{ALP_DATA}/v1beta3/crypto/us/quotes/latest"
            js=await http_json(session, url, params={"symbols":symbol}, headers=alp_headers())
            q=((js.get("quotes") or {}).get(symbol) or {}).get("quote") or {}
            bp=float(q.get("bp",0)); ap=float(q.get("ap",0))
        if ap<=0 or bp<=0 or ap<bp: return 9999.0
        return (ap-bp)/ap*10000.0
    except:
        return 9999.0

# ============== CORE SCORING =============
def mtf_votes(cl: List[float]) -> Dict[str, float]:
    out={"vote":0,"rsi":None,"ema":0,"macd":None,"sig":None}
    if len(cl)<60: return out
    rr=rsi(cl,14); m,s=macd(cl)
    e20=ema(cl,20); e50=ema(cl,50)
    if rr: out["rsi"]=rr[-1]; 
    if m and s: out["macd"]=m[-1]; out["sig"]=s[-1]; out["vote"] += 1 if m[-1]>s[-1] else -1
    if e20 and e50:
        tr=1 if e20[-1]>e50[-1] else -1
        out["ema"]=tr; out["vote"] += 1 if tr==1 else -1
    return out

def decide_direction(v15:int,v30:int,v60:int, need:int) -> Optional[str]:
    total=v15+v30+v60
    pos=sum(1 for v in (v15,v30,v60) if v>0)
    neg=sum(1 for v in (v15,v30,v60) if v<0)
    if total>=need and pos>=2: return "LONG"
    if total<=-need and neg>=2: return "SHORT"
    return None

def quality_score(direction: str, px: float, sl: float, tp: float,
                  c15: List[float], c30: List[float], c60: List[float],
                  adx30: float, adx60: float) -> int:
    score=0
    risk=abs(px-sl); reward=abs(tp-px)
    rr=reward/max(1e-9,risk)
    if rr>=2.4: score+=2
    elif rr>=2.0: score+=1
    else: score-=1

    e30_20, e30_50 = ema(c30,20), ema(c30,50)
    e60_20, e60_50 = ema(c60,20), ema(c60,50)
    if e30_20 and e30_50:
        t30 = 1 if e30_20[-1]>e30_50[-1] else -1
        score += 1 if (direction=="LONG" and t30==1) or (direction=="SHORT" and t30==-1) else 0
    if e60_20 and e60_50:
        t60 = 1 if e60_20[-1]>e60_50[-1] else -1
        score += 1 if (direction=="LONG" and t60==1) or (direction=="SHORT" and t60==-1) else 0

    if adx60>adx30: score+=1
    r15=rsi(c15,14)
    if r15:
        if direction=="LONG" and r15[-1]>82: score-=1
        if direction=="SHORT" and r15[-1]<18: score-=1
    return score

# ============== CSV LOG =================
def log_signal_row(row: dict):
    try:
        new_file = not os.path.exists(LOG_PATH)
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=[
                "utc","asset_class","symbol","dir","px","sl","tp","rr","q","atrpct","adx30","adx60","spread_bps","turnover_m"
            ])
            if new_file: w.writeheader()
            w.writerow(row)
    except Exception as e:
        log.error("CSV log err: %s", e)

# ============== SCAN & SIGNALS ==========
async def scan_all_and_trade(st: Dict[str,object]) -> str:
    mode = st.get("mode","safe")
    filt = st["filters_aggr"] if mode=="aggr" else st["filters"]
    min_adx = float(filt["min_adx"]); sl_k=float(filt["sl_k"]); rr_k=float(filt["rr_k"])
    min_atr_pct=float(filt["min_atr_pct"]); vol_mult=float(filt["vol_mult"])

    top_n = int(st.get("top_n", TOP_N))
    place_orders = bool(st.get("alp_on", False))
    notional = float(st.get("notional", NOTIONAL))

    # –¥—ñ–∑–Ω–∞—Ç–∏—Å—å —á–∏ —Ä–∏–Ω–æ–∫ –∞–∫—Ü—ñ–π –≤—ñ–¥–∫—Ä–∏—Ç–∏–π
    async with aiohttp.ClientSession() as s:
        try:
            ck = await alp_clock(s)
            stocks_open = bool(ck.get("is_open", False))
        except Exception as e:
            stocks_open = True  # —è–∫—â–æ –Ω–µ –∑–º–æ–≥–ª–∏ ‚Äî –Ω–µ –±–ª–æ–∫—É–≤–∞—Ç–∏ –∞–∫—Ü—ñ—ó
            log.warning("clock error: %s", e)

        syms_stocks=[]; syms_crypto=[]
        # –∞–∫—Ç–∏–≤–∏
        try:
            if stocks_open:
                A = await alp_assets(s, "us_equity")
                syms_stocks = [a["symbol"] for a in A if a.get("tradable")]
                syms_stocks = syms_stocks[:MAX_STOCKS]
            A = await alp_assets(s, "crypto")
            syms_crypto = [a["symbol"] for a in A if a.get("tradable")]
            syms_crypto = syms_crypto[:MAX_CRYPTO]
        except Exception as e:
            log.error("assets err: %s", e)

        scored=[]

        async def process_symbol(sym: str, aclass: str):
            # –±–∞—Ä–∏
            try:
                if aclass=="stocks":
                    o15,h15,l15,c15,v15 = await bars_stocks(s, sym, "15Min", 300); await asyncio.sleep(0.02)
                    o30,h30,l30,c30,v30 = await bars_stocks(s, sym, "30Min", 300); await asyncio.sleep(0.02)
                    o60,h60,l60,c60,v60 = await bars_stocks(s, sym, "1Hour", 300)
                else:
                    o15,h15,l15,c15,v15 = await bars_crypto(s, sym, "15Min", 300); await asyncio.sleep(0.02)
                    o30,h30,l30,c30,v30 = await bars_crypto(s, sym, "30Min", 300); await asyncio.sleep(0.02)
                    o60,h60,l60,c60,v60 = await bars_crypto(s, sym, "1Hour", 300)
            except Exception:
                return

            if not (c15 and c30 and c60): return
            px=float(c15[-1]); 
            if px<=0: return

            # approx 24h change and turnover(15m*96)
            try:
                idx=max(0,len(c15)-96); ref=float(c15[idx]) if idx<len(c15) else float(c15[0])
                ch24=(px/ref-1.0)*100.0 if ref>0 else 0.0
            except: ch24=0.0

            tv=0.0
            for cc,vv in zip(c15[max(0,len(c15)-96):], v15[max(0,len(v15)-96):]):
                try: tv += float(cc)*float(vv)
                except: pass
            turnover_m = tv/1e6

            sp = await spread_bps(s, sym, aclass)
            if sp>12.0:  # –Ω–∞–¥—Ç–æ —à–∏—Ä–æ–∫–∏–π —Å–ø—Ä–µ–¥
                return

            # –æ–±—Å—è–≥ –Ω–∞ 15–º –≤—ñ–¥–Ω–æ—Å–Ω–æ SMA20
            vsma=sma_series(v15,20)
            if vsma and vsma[-1] is not None:
                if v15[-1] <= vol_mult*float(vsma[-1]): 
                    return

            # –≥–æ–ª–æ—Å—É–≤–∞–Ω–Ω—è –ø–æ 15/30/60
            v15x=mtf_votes(c15); v30x=mtf_votes(c30); v60x=mtf_votes(c60)
            side = decide_direction(v15x["vote"], v30x["vote"], v60x["vote"], need=3 if mode=="safe" else 2)
            if not side: 
                return

            # ADX
            adx30=adx_last(h30,l30,c30,14); adx60=adx_last(h60,l60,c60,14)
            if min(adx30,adx60) < min_adx:
                return

            # ATR
            atrv = atr_value(h15,l15,c15,14)
            if atrv<=0: 
                return
            atrpct = 100.0*atrv/px
            if atrpct < min_atr_pct:
                return

            # SL/TP
            if side=="LONG":
                sl=px - sl_k*atrv; risk=px-sl; tp=px + rr_k*risk
            else:
                sl=px + sl_k*atrv; risk=sl-px; tp=px - rr_k*risk
            rr = abs(tp-px)/max(1e-9,abs(px-sl))

            q = quality_score(side, px, sl, tp, c15, c30, c60, adx30, adx60)
            score = (v15x["vote"]+v30x["vote"]+v60x["vote"]) + q
            scored.append((score, aclass, sym, side, px, sl, tp, rr, atrpct, adx30, adx60, sp, turnover_m))

        # –ü–∞—Ä–∞–ª–µ–ª—å–Ω–æ, –∞–ª–µ –æ–±–º–µ–∂–∏–º–æ —Ç–∞—Å–∫–∏, —â–æ–± –Ω–µ –≤–ø–µ—Ä—Ç–∏—Å—å —É –ª—ñ–º—ñ—Ç–∏
        sem = asyncio.Semaphore(20)
        async def guard(sym, aclass):
            async with sem:
                await process_symbol(sym,aclass)

        tasks=[]
        if stocks_open:
            for sym in syms_stocks:
                tasks.append(asyncio.create_task(guard(sym,"stocks")))
        for sym in syms_crypto:
            tasks.append(asyncio.create_task(guard(sym,"crypto")))
        if tasks:
            await asyncio.gather(*tasks)

        if not scored:
            return "‚ö†Ô∏è –ù–µ–º–∞—î –Ω–∞–¥—ñ–π–Ω–∏—Ö –≤—Ö–æ–¥—ñ–≤ –ø—Ä–æ—Å—Ç–æ –∑–∞—Ä–∞–∑."

        scored.sort(key=lambda x: x[0], reverse=True)
        top = scored[:max(1,top_n)]

        # –ü–æ–±—É–¥—É–≤–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —ñ (–∑–∞ –ø–æ—Ç—Ä–µ–±–∏) –ø–æ—Å—Ç–∞–≤–∏—Ç–∏ –æ—Ä–¥–µ—Ä–∏
        out_lines=[]
        placed=[]
        for sc, aclass, sym, side, px, sl, tp, rr, atrpct, adx30, adx60, sp, tov in top:
            out_lines.append(
                f"‚Ä¢ *{sym}* _({aclass})_: *{side}* @ `{px:.4f}` | SL `{sl:.4f}` | TP `{tp:.4f}` | RR `{rr:.2f}`\n"
                f"  ATR%‚âà{atrpct:.2f}% ¬∑ ADX30:{adx30:.0f} ADX1h:{adx60:.0f} ¬∑ spread:{sp:.1f}bps ¬∑ TV‚âà{tov:.1f}M"
            )
            # –ª–æ–≥
            try:
                log_signal_row({
                    "utc": utc_now_str(),"asset_class": aclass,"symbol": sym,"dir": side,"px": f"{px:.6f}",
                    "sl": f"{sl:.6f}","tp": f"{tp:.6f}","rr": f"{rr:.2f}","q": sc,
                    "atrpct": f"{atrpct:.2f}","adx30": f"{adx30:.1f}","adx60": f"{adx60:.1f}",
                    "spread_bps": f"{sp:.1f}","turnover_m": f"{tov:.1f}"
                })
            except Exception as e:
                log.error("csv err: %s", e)

        if place_orders:
            # —Å—Ç–∞–≤–∏–º–æ —Ç—ñ–ª—å–∫–∏ —Ç—ñ, –¥–ª—è —è–∫–∏—Ö —Ç–æ—Ä–≥ –¥–æ–∑–≤–æ–ª–µ–Ω–∏–π: —è–∫—â–æ –∞–∫—Ü—ñ—ó –∑–∞–∫—Ä–∏—Ç—ñ ‚Äî —Å–∫—ñ–ø –∞–∫—Ü—ñ—ó
            for sc, aclass, sym, side, px, sl, tp, rr, atrpct, adx30, adx60, sp, tov in top:
                if aclass=="stocks" and not stocks_open:
                    continue
                side_str="buy" if side=="LONG" else "sell"
                payload={
                    "symbol": sym,
                    "side": side_str,
                    "type": "market",
                    "notional": round(notional,2),
                    "time_in_force": "gtc",
                    "order_class": "bracket",
                    "take_profit": {"limit_price": round(tp,4)},
                    "stop_loss": {"stop_price": round(sl,4)}
                }
                try:
                    od = await alp_place_order(s, payload)
                    oid = od.get("id","?")
                    placed.append(f"‚úÖ {side} {sym} ~{px:.4f} notional {notional:.2f} ‚Üí id `{oid}`")
                except Exception as e:
                    placed.append(f"‚ùå {side} {sym}: {e}")

        msg = "üìà *Alpaca ‚Äî –∫—Ä–∞—â—ñ –≤—Ö–æ–¥–∏ (USD)*\n\n" + "\n\n".join(out_lines)
        if place_orders and placed:
            msg += "\n\n" + "\n".join(placed)
        msg += f"\n\nUTC: {utc_now_str()}"
        return msg

# ================= TELEGRAM ==============
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    STATE.setdefault(u.effective_chat.id, default_state())
    try:
        await c.bot.set_my_commands([
            BotCommand("signals", "–°–∫–∞–Ω—É–≤–∞—Ç–∏ –∑–∞—Ä–∞–∑"),
            BotCommand("alp_on", "–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥"),
            BotCommand("alp_off", "–í–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥"),
            BotCommand("alp_status", "–°—Ç–∞—Ç—É—Å –∞–∫–∞—É–Ω—Ç—É"),
            BotCommand("mode_aggr", "–†–µ–∂–∏–º: —à–≤–∏–¥–∫–∏–π"),
            BotCommand("mode_safe", "–†–µ–∂–∏–º: –Ω–∞–¥—ñ–π–Ω–∏–π"),
            BotCommand("set_top", "–°–∫—ñ–ª—å–∫–∏ —Ç–æ–ø-—É–≥–æ–¥ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏"),
            BotCommand("set_notional", "–ù–æ–º—ñ–Ω–∞–ª –Ω–∞ —É–≥–æ–¥—É ($)")
        ])
    except Exception:
        pass
    await u.message.reply_text(
        "üëã Alpaca USD –±–æ—Ç –≥–æ—Ç–æ–≤–∏–π.\n"
        "‚Ä¢ /signals ‚Äî –∞–Ω–∞–ª—ñ–∑ —É—Å—ñ—Ö –∞–∫—Ü—ñ–π —ñ –∫—Ä–∏–ø—Ç–∏.\n"
        "‚Ä¢ /alp_on /alp_off ‚Äî –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ (—Ä–∏–Ω–∫–æ–≤–∏–π notional + bracket TP/SL).\n"
        "‚Ä¢ /mode_aggr –∞–±–æ /mode_safe ‚Äî –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è —Ñ—ñ–ª—å—Ç—Ä—ñ–≤.\n"
        "‚Ä¢ /set_top N, /set_notional $ ‚Äî –±–∞–∑–æ–≤—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è.",
        reply_markup=_kb({})
    )

async def help_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    txt=(
        "üìò –î–æ–≤—ñ–¥–∫–∞\n\n"
        "‚Äî –ë–æ—Ç –∞–Ω–∞–ª—ñ–∑—É—î *–≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ* —É Alpaca –∞–∫—Ç–∏–≤–∏: US –∞–∫—Ü—ñ—ó —Ç–∞ –∫—Ä–∏–ø—Ç–æ.\n"
        "‚Äî –Ø–∫—â–æ —Ä–∏–Ω–æ–∫ –∞–∫—Ü—ñ–π –∑–∞–∫—Ä–∏—Ç–∏–π, —Ç–æ—Ä–≥—É—î—Ç—å—Å—è –ª–∏—à–µ –∫—Ä–∏–ø—Ç–∞ (24/7).\n"
        "‚Äî –†–µ–∂–∏–º–∏:\n"
        "   ‚Ä¢ /mode_aggr ‚Äî —à–≤–∏–¥—à—ñ –≤—Ö–æ–¥–∏ (–Ω–∏–∂—á—ñ –ø–æ—Ä–æ–≥–∏ ADX/ATR).\n"
        "   ‚Ä¢ /mode_safe ‚Äî —Å—É–≤–æ—Ä—ñ—à—ñ —Ñ—ñ–ª—å—Ç—Ä–∏ (–∑–∞ –∑–∞–º–æ–≤—á.).\n"
        "‚Äî –ê–≤—Ç–æ—Ç—Ä–µ–π–¥: /alp_on ‚Üí MARKET notional + bracket TP/SL (ATR), /alp_off ‚Äî –≤–∏–º–∫.\n"
        "‚Äî –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è: /set_top 10, /set_notional 50.\n"
    )
    await u.message.reply_text(txt)

async def alp_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    st["alp_on"]=True
    await u.message.reply_text("‚úÖ AUTOTRADE: ON", reply_markup=_kb(st))

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    st["alp_on"]=False
    await u.message.reply_text("‚è∏ AUTOTRADE: OFF", reply_markup=_kb(st))

async def alp_status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    try:
        async with aiohttp.ClientSession() as s:
            js = await http_json(s, f"{ALP_BASE}/account", headers=alp_headers())
        txt=(f"üíº Alpaca: status={js.get('status','?')} ¬∑ "
             f"cash=${float(js.get('cash',0)):.2f} ¬∑ "
             f"buying_power=${float(js.get('buying_power',0)):.2f} ¬∑ "
             f"equity=${float(js.get('equity',0)):.2f}")
        await u.message.reply_text(txt)
    except Exception as e:
        await u.message.reply_text(f"‚ùå Alpaca error: {e}")

async def mode_aggr_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    st["mode"]="aggr"
    await u.message.reply_text("‚ö° –†–µ–∂–∏–º: –®–í–ò–î–ö–ò–ô (–∞–≥—Ä–µ—Å–∏–≤–Ω–∏–π).", reply_markup=_kb(st))

async def mode_safe_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    st["mode"]="safe"
    await u.message.reply_text("üõ°Ô∏è –†–µ–∂–∏–º: –ù–ê–î–Ü–ô–ù–ò–ô (—Å—É–≤–æ—Ä—ñ —Ñ—ñ–ª—å—Ç—Ä–∏).", reply_markup=_kb(st))

async def set_top_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    try:
        v=int(c.args[0]); assert 1<=v<=50
        st["top_n"]=v
        await u.message.reply_text(f"OK. TOP_N = {v}.")
    except:
        await u.message.reply_text("–§–æ—Ä–º–∞—Ç: /set_top 10 (1..50)")

async def set_notional_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st=STATE.setdefault(u.effective_chat.id, default_state())
    try:
        v=float(c.args[0]); assert 1<=v<=100000
        st["notional"]=v
        await u.message.reply_text(f"OK. Notional = ${v:.2f} –Ω–∞ —É–≥–æ–¥—É.")
    except:
        await u.message.reply_text("–§–æ—Ä–º–∞—Ç: /set_notional 50")

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    msg = await scan_all_and_trade(st)
    for chunk in split_long(msg, 3500):
        await u.message.reply_text(chunk, parse_mode=ParseMode.MARKDOWN)

def split_long(text: str, n: int = 3500) -> List[str]:
    out=[]; i=0
    while i<len(text):
        j=min(len(text), i+n)
        cut=text.rfind("\n\n", i, j)
        if cut==-1: cut=text.rfind("\n", i, j)
        if cut==-1 or cut<i+200: cut=j
        seg=text[i:cut]
        if seg.count("`")%2==1: seg+="`"
        out.append(seg); i=cut
    return out

# ============== MAIN ====================
def register(app: Application):
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("signals", signals_cmd))
    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", alp_status_cmd))
    app.add_handler(CommandHandler("mode_aggr", mode_aggr_cmd))
    app.add_handler(CommandHandler("mode_safe", mode_safe_cmd))
    app.add_handler(CommandHandler("set_top", set_top_cmd))
    app.add_handler(CommandHandler("set_notional", set_notional_cmd))

async def main():
    if not TG_TOKEN: raise SystemExit("Set TELEGRAM_BOT_TOKEN")
    if not (ALP_KEY and ALP_SECRET): log.warning("‚ö†Ô∏è ALPACA keys not set ‚Äî /alp_status —Ç–∞ –æ—Ä–¥–µ—Ä–∏ –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º—É—Ç—å.")
    app = Application.builder().token(TG_TOKEN).build()
    register(app)
    log.info("Alpaca bot started")
    await app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
