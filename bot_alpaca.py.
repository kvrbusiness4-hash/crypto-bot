# main.py
# ProfitSignalsBot ‚Äî Alpaca autotrade (stocks + crypto), no whitelists by default
# Requires: python-telegram-bot>=20.6, aiohttp>=3.9, python-dotenv (optional)

import asyncio, os, re, math, json, time, random
from datetime import datetime, timezone
from typing import Dict, Any, List, Tuple, Optional

import aiohttp
from aiohttp import ClientSession, ClientTimeout

from telegram import (
    Update, ReplyKeyboardMarkup, KeyboardButton,
)
from telegram.ext import (
    Application, ApplicationBuilder, AIORateLimiter,
    CommandHandler, ContextTypes,
)

# =========================
# ENV / CONFIG
# =========================

def env_float(name: str, default: float) -> float:
    try:
        return float(os.getenv(name, str(default)))
    except Exception:
        return default

def env_int(name: str, default: int) -> int:
    try:
        return int(os.getenv(name, str(default)))
    except Exception:
        return default

TELEGRAM_TOKEN      = os.getenv("TELEGRAM_BOT_TOKEN", "")
ALPACA_API_KEY      = os.getenv("ALPACA_API_KEY", "")
ALPACA_API_SECRET   = os.getenv("ALPACA_API_SECRET", "")
ALPACA_BASE_URL     = os.getenv("ALPACA_BASE_URL", "https://paper-api.alpaca.markets/v2")
ALPACA_DATA_URL     = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
ALPACA_ENABLE       = os.getenv("ALPACA_ENABLE", "1") == "1"

# —Ç–æ—Ä–≥–æ–≤–∞ —Å—É–º–∞ –∑–∞ —É–≥–æ–¥—É (USD notional)
ALPACA_NOTIONAL     = env_float("ALPACA_NOTIONAL", 50.0)

# –º–µ–∂—ñ –Ω–∞ —É–Ω—ñ–≤–µ—Ä—Å—É–º (—â–æ–± –Ω–µ –≤–ø–µ—Ä—Ç–∏—Å—è –≤ –ª—ñ–º—ñ—Ç–∏ API)
MAX_STOCKS          = env_int("ALPACA_MAX_STOCKS", 1500)
MAX_CRYPTO          = env_int("ALPACA_MAX_CRYPTO", 150)

# –ø–µ—Ä—ñ–æ–¥ –∞–≤—Ç–æ—Å–∫–∞–Ω—É
SCAN_EVERY_SEC      = env_int("SCAN_EVERY_SEC", 120)

# –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ñ—Å—Ç—å –∑–∞–ø–∏—Ç—ñ–≤ –¥–æ Data API (–∞–∫—É—Ä–∞—Ç–Ω–æ –∑ –ª—ñ–º—ñ—Ç–∞–º–∏)
DATA_CONCURRENCY    = env_int("DATA_CONCURRENCY", 10)
HTTP_TIMEOUT        = env_int("HTTP_TIMEOUT", 20)

# =========================
# STATE (in-memory)
# =========================

def default_state() -> Dict[str, Any]:
    return {
        "mode": "default",          # –ø—Ä–æ—Ñ—ñ–ª—å
        "autotrade": False,         # —Å—Ç–∞–≤–∏—Ç–∏ –æ—Ä–¥–µ—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
        "use_whitelist": False,     # –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º ‚Äî –°–ö–ê–ù –í–°–ï
        "wl_stocks": [],            # —è–∫—â–æ use_whitelist=True
        "wl_crypto": [],

        # —Å–µ—Å—ñ—è –¥–ª—è –∞–∫—Ü—ñ–π —É UTC (–Ω–∞–ø—Ä. 12..20)
        "sess_start": 12,
        "sess_end": 20,

        # –æ—Å—Ç–∞–Ω–Ω—ñ–π —Ç–µ–∫—Å—Ç –∑–≤—ñ—Ç—É
        "last_scan_txt": "",
    }

STATE: Dict[int, Dict[str, Any]] = {}

def now_utc() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

def utc_hour() -> int:
    return int(datetime.now(timezone.utc).strftime("%H"))

def fmt_usd(x: float) -> str:
    try: return f"${x:,.2f}"
    except: return str(x)

# =========================
# HTTP helpers
# =========================

def alp_headers() -> Dict[str, str]:
    return {
        "APCA-API-KEY-ID": ALPACA_API_KEY,
        "APCA-API-SECRET-KEY": ALPACA_API_SECRET,
        "Content-Type": "application/json",
        "Accept": "application/json",
        "User-Agent": "ProfitSignalsBot/1.0",
    }

def tg_keyboard() -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton("/signals_alpaca"), KeyboardButton("/alp_status")],
        [KeyboardButton("/alp_on"), KeyboardButton("/alp_off")],
        [KeyboardButton("/wl_off"), KeyboardButton("/wl_on"), KeyboardButton("/wl_clear")],
        [KeyboardButton("/set_session 12 20"), KeyboardButton("/status")],
        [KeyboardButton("/help")],
    ]
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# =========================
# Alpaca API (REST)
# =========================

async def http_json(session: ClientSession, method: str, url: str, **kw) -> Any:
    async with session.request(method, url, timeout=ClientTimeout(total=HTTP_TIMEOUT), **kw) as r:
        if r.status >= 400:
            txt = await r.text()
            raise RuntimeError(f"HTTP {r.status} {url} -> {txt}")
        ct = r.headers.get("content-type", "")
        if "application/json" in ct:
            return await r.json()
        return await r.text()

async def alp_account(session: ClientSession) -> Dict[str, Any]:
    url = f"{ALPACA_BASE_URL}/account"
    return await http_json(session, "GET", url, headers=alp_headers())

async def alp_clock(session: ClientSession) -> Dict[str, Any]:
    # Alpaca still supports /v2/clock
    url = f"{ALPACA_BASE_URL}/clock"
    return await http_json(session, "GET", url, headers=alp_headers())

async def alp_assets(session: ClientSession, asset_class: str) -> List[Dict[str, Any]]:
    # asset_class: 'us_equity' | 'crypto'
    url = f"{ALPACA_BASE_URL}/assets?status=active&tradable=true&asset_class={asset_class}"
    resp = await http_json(session, "GET", url, headers=alp_headers())
    # resp ‚Äî —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤—ñ–≤
    return resp if isinstance(resp, list) else []

async def latest_daily_change(session: ClientSession, symbol: str, is_crypto: bool) -> Optional[float]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î % –∑–º—ñ–Ω–∏ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –¥–µ–Ω—å (close/prev_close-1)*100
    –î–ª—è –∞–∫—Ü—ñ–π: /v2/stocks/{symbol}/bars?timeframe=1Day&limit=2
    –î–ª—è –∫—Ä–∏–ø—Ç–∏: /v1beta3/crypto/us/bars?symbols={symbol}&timeframe=1Day&limit=2
    """
    try:
        if not is_crypto:
            url = f"{ALPACA_DATA_URL}/v2/stocks/{symbol}/bars?timeframe=1Day&limit=2&adjustment=all"
            data = await http_json(session, "GET", url, headers=alp_headers())
            bars = data.get("bars", [])
        else:
            # v1beta3 crypto
            url = f"{ALPACA_DATA_URL}/v1beta3/crypto/us/bars?symbols={symbol}&timeframe=1Day&limit=2"
            data = await http_json(session, "GET", url, headers=alp_headers())
            bars = data.get("bars", {}).get(symbol, [])

        if len(bars) < 2:
            return None
        prev_close = float(bars[-2].get("c"))
        last_close = float(bars[-1].get("c"))
        if prev_close <= 0: return None
        chg = (last_close / prev_close - 1.0) * 100.0
        return chg
    except Exception:
        return None

async def place_market_notional(session: ClientSession, symbol: str, side: str, notional: float, is_crypto: bool) -> Dict[str, Any]:
    """
    –°—Ç–∞–≤–∏–º–æ MARKET notional order (USD). –î–ª—è crypto Alpaca —Ç–µ–∂ –ø—Ä–∏–π–º–∞—î notional —É USD.
    """
    url = f"{ALPACA_BASE_URL}/orders"
    payload = {
        "symbol": symbol,
        "side": side,                # 'buy' | 'sell'
        "type": "market",
        "time_in_force": "day" if not is_crypto else "gtc",
        "notional": round(notional, 2),
    }
    return await http_json(session, "POST", url, data=json.dumps(payload), headers=alp_headers())

# =========================
# Universe builder
# =========================

async def build_universe(session: ClientSession, st: Dict[str, Any], market_open: bool) -> Tuple[List[str], List[str]]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î (stocks_symbols, crypto_symbols) –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ —Ä–µ–∂–∏–º—É (use_whitelist —á–∏ –Ω—ñ)
    —Ç–∞ –æ–±–º–µ–∂–µ–Ω—å MAX_*.
    """
    if st.get("use_whitelist"):
        s = st.get("wl_stocks", [])[:MAX_STOCKS]
        c = st.get("wl_crypto", [])[:MAX_CRYPTO]
        # —Ñ—ñ–ª—å—Ç—Ä—É—î–º–æ —Ç—ñ–ª—å–∫–∏ USD –∫—Ä–∏–ø—Ç–æ
        c = [x for x in c if x.endswith("USD")]
        return (s, c)

    # –°–∫–∞–Ω—É—î–º–æ –í–°–ï
    stocks, crypto = [], []
    try:
        if market_open:
            a = await alp_assets(session, "us_equity")
            stocks = [x.get("symbol") for x in a if x.get("symbol") and x.get("tradable")]
            stocks = stocks[:MAX_STOCKS]
        # –∫—Ä–∏–ø—Ç–∞ ‚Äî –∑–∞–≤–∂–¥–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ (–∞–ª–µ –º–∏ —Ç–æ—Ä–≥—É—î–º–æ –ø–æ–∑–∞ —Å–µ—Å—ñ—î—é –∑–∞ –ø—Ä–∞–≤–∏–ª–∞–º–∏)
        a = await alp_assets(session, "crypto")
        crypto = [x.get("symbol") for x in a if x.get("symbol","").endswith("USD") and x.get("tradable")]
        crypto = crypto[:MAX_CRYPTO]
    except Exception:
        pass
    return (stocks, crypto)

# =========================
# Simple signal model
# =========================

async def score_symbol(session: ClientSession, symbol: str, is_crypto: bool) -> Optional[Tuple[float, float]]:
    """
    –û–±—á–∏—Å–ª—é—î–º–æ –ø—Ä–æ—Å—Ç–∏–π —Å–∫–æ—Ä:
      - daily %change (–æ—Å—Ç–∞–Ω–Ω—ñ–π –¥–µ–Ω—å)
      - –ø—Ä–∞—Ü—é—î–º–æ –∑ –∞–±—Å–æ–ª—é—Ç–Ω–∏–º –∑–Ω–∞—á–µ–Ω–Ω—è–º > 2% —ñ < 20%
      - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ (score, change%)
    """
    chg = await latest_daily_change(session, symbol, is_crypto)
    if chg is None: 
        return None
    achg = abs(chg)
    if achg < 2 or achg > 20:
        return None
    # –ø—Ä–æ—Å—Ç–∏–π —Å–∫–æ—Ä ‚Äî —á–∏–º –±–ª–∏–∂—á–µ 8‚Äì12%, —Ç–∏–º –∫—Ä–∞—â–µ
    score = max(0.0, 12.0 - abs(10.0 - achg))
    return (score, chg)

async def scan_all(st: Dict[str, Any]) -> Tuple[str, List[str], List[str]]:
    """
    –°–∫–∞–Ω–∏ –≤—Å–µ—Å–≤—ñ—Ç. –§–æ—Ä–º—É—î —Ç–µ–∫—Å—Ç –∑–≤—ñ—Ç—É + —Å–ø–∏—Å–∫–∏ —Ç–æ–ø—ñ–≤ (stocks, crypto)
    """
    market_open = False
    async with aiohttp.ClientSession() as session:
        # market open –∑–∞ Alpaca clock
        try:
            clk = await alp_clock(session)
            market_open = bool(clk.get("is_open", False))
        except Exception:
            # —Ä–µ–∑–µ—Ä–≤: –∑–∞ —Å–µ—Å—ñ—î—é –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ (UTC)
            h = utc_hour()
            market_open = st.get("sess_start", 12) <= h <= st.get("sess_end", 20)

        stocks, crypto = await build_universe(session, st, market_open)

        # –°–∫–∞–Ω—É—î–º–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ, –∞–ª–µ –≤ –º–µ–∂–∞—Ö DATA_CONCURRENCY
        async def eval_many(symbols: List[str], is_crypto: bool, topn: int) -> List[Tuple[str,float,float]]:
            out: List[Tuple[str,float,float]] = []
            sem = asyncio.Semaphore(DATA_CONCURRENCY)
            async def one(sym: str):
                async with sem:
                    sc = await score_symbol(session, sym, is_crypto)
                    if sc:
                        out.append((sym, sc[0], sc[1]))
            await asyncio.gather(*(one(s) for s in symbols))
            out.sort(key=lambda x: x[1], reverse=True)
            return out[:topn]

        top_stocks = []
        top_crypto = []

        if market_open and stocks:
            top_stocks = await eval_many(stocks, False, 20)
        if crypto:
            top_crypto = await eval_many(crypto, True, 20)

        # —Ñ–æ—Ä–º—É—î–º–æ —Ä–µ–ø–æ—Ä—Ç
        def render(title: str, arr: List[Tuple[str,float,float]]) -> str:
            if not arr: return f"‚Ä¢ {title}: ‚Äî"
            lines = [f"‚Ä¢ {title}:"]
            for sym, sc, ch in arr[:10]:
                lines.append(f"  {sym:>8}  score={sc:.2f}  Œî1d={ch:+.2f}%")
            return "\n".join(lines)

        rep = [
            f"üõ∞ Scan @ {now_utc()}",
            f"Market open (stocks): {'YES' if market_open else 'NO'}",
            render("Top Stocks", top_stocks),
            render("Top Crypto (USD)", top_crypto),
        ]
        return ("\n".join(rep), [x[0] for x in top_stocks], [x[0] for x in top_crypto])

# =========================
# Placing orders by rules
# =========================

async def place_orders(st: Dict[str, Any], session: ClientSession, chat_id: int, market_open: bool, picks_s: List[str], picks_c: List[str]) -> List[str]:
    if not ALPACA_ENABLE or not st.get("autotrade"):
        return []

    placed: List[str] = []

    # –ø—Ä–æ—Å—Ç—ñ –ø—Ä–∞–≤–∏–ª–∞:
    # ‚Äì —è–∫—â–æ market_open=True: –Ω–∞–º–∞–≥–∞—î–º–æ—Å—è –≤–∑—è—Ç–∏ –¥–æ 2 –∫—Ä–∞—â–∏—Ö –∞–∫—Ü—ñ–π
    # ‚Äì —è–∫—â–æ market_open=False: –¥–æ 2 –∫—Ä–∏–ø—Ç–æ-–ø–∞—Ä
    try:
        if market_open and picks_s:
            for sym in picks_s[:2]:
                try:
                    r = await place_market_notional(session, sym, "buy", ALPACA_NOTIONAL, False)
                    placed.append(f"BUY {sym} ${ALPACA_NOTIONAL:.2f} ‚úÖ")
                except Exception as e:
                    placed.append(f"BUY {sym} ‚ùå {e}")
        elif (not market_open) and picks_c:
            for sym in picks_c[:2]:
                try:
                    r = await place_market_notional(session, sym, "buy", ALPACA_NOTIONAL, True)
                    placed.append(f"BUY {sym} ${ALPACA_NOTIONAL:.2f} ‚úÖ")
                except Exception as e:
                    placed.append(f"BUY {sym} ‚ùå {e}")
    except Exception as e:
        placed.append(f"Order flow error: {e}")
    return placed

# =========================
# Telegram Handlers
# =========================

async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    await u.message.reply_text(
        "üëã –ì–æ—Ç–æ–≤–æ. –ë–æ—Ç –≤–∏–¥–∞—î —Å–∏–≥–Ω–∞–ª–∏ —ñ (–∑–∞ –±–∞–∂–∞–Ω–Ω—è–º) —Å—Ç–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä–∏ –≤ Alpaca.\n"
        "‚Ä¢ /alp_on ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ¬∑ /alp_status ‚Äî —Å—Ç–∞–Ω –∞–∫–∞—É–Ω—Ç—É\n"
        "‚Ä¢ /wl_off ‚Äî —Å–∫–∞–Ω—É–≤–∞—Ç–∏ –í–°–Ü –∞–∫—Ç–∏–≤–∏ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º) ¬∑ /wl_on ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏ whitelist ¬∑ /wl_clear ‚Äî –æ—á–∏—Å—Ç–∏—Ç–∏\n"
        "‚Ä¢ /set_session HH HH ‚Äî –≥–æ–¥–∏–Ω–∏ UTC –¥–ª—è –∞–∫—Ü—ñ–π (–Ω–∞–ø—Ä. /set_session 12 20)\n"
        "‚Ä¢ /signals_alpaca ‚Äî —Å–∫–∞–Ω + (—è–∫—â–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ON) –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä—ñ–≤\n",
        reply_markup=tg_keyboard()
    )

async def alp_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = True
    await u.message.reply_text("‚úÖ Alpaca AUTOTRADE: ON")

async def alp_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["autotrade"] = False
    await u.message.reply_text("üü® Alpaca AUTOTRADE: OFF")

async def status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    await u.message.reply_text(
        f"‚ÑπÔ∏è Mode={st.get('mode')} ¬∑ Autotrade={'ON' if st.get('autotrade') else 'OFF'} ¬∑ "
        f"Whitelist={'ON' if st.get('use_whitelist') else 'OFF'} ¬∑ "
        f"Stocks session UTC {st.get('sess_start')}-{st.get('sess_end')} ¬∑ {now_utc()}")

async def set_session_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    try:
        parts = u.message.text.strip().split()
        s, e = int(parts[1]), int(parts[2])
        s = max(0, min(23, s))
        e = max(0, min(23, e))
        st["sess_start"], st["sess_end"] = s, e
        await u.message.reply_text(f"OK. –°–µ—Å—ñ—è UTC {s:02d}-{e:02d}.")
    except Exception:
        await u.message.reply_text("–ü—Ä–∏–∫–ª–∞–¥: /set_session 12 20")

async def wl_off_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["use_whitelist"] = False
    await u.message.reply_text("‚úÖ Whitelist OFF. –°–∫–∞–Ω—É—î–º–æ –í–°–Ü –∞–∫—Ç–∏–≤–∏.")

async def wl_on_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["use_whitelist"] = True
    await u.message.reply_text("üü® Whitelist ON. –î–ª—è —Å–∫–∞–Ω—É –±–µ—Ä–µ–º–æ –ª–∏—à–µ wl-—Å–ø–∏—Å–∫–∏.")

async def wl_clear_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    st["wl_stocks"], st["wl_crypto"] = [], []
    await u.message.reply_text("üßπ Whitelists –æ—á–∏—â–µ–Ω–æ.")

async def alp_status_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    async with aiohttp.ClientSession() as session:
        try:
            acc = await alp_account(session)
            txt = (
                f"üíº Alpaca: status={acc.get('status','?')}\n"
                f"‚Ä¢ cash={fmt_usd(float(acc.get('cash',0)))} ¬∑ "
                f"buying_power={fmt_usd(float(acc.get('buying_power',0)))} ¬∑ "
                f"equity={fmt_usd(float(acc.get('equity',0)))}"
            )
        except Exception as e:
            txt = f"‚ùå Alpaca error: {e}"
    await u.message.reply_text(txt)

async def signals_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    st = STATE.setdefault(u.effective_chat.id, default_state())
    # —Å–∫–∞–Ω
    rep, picks_s, picks_c = await scan_all(st)
    st["last_scan_txt"] = rep

    # –≤–∏–∑–Ω–∞—á–∞—î–º–æ open/close
    market_open = False
    try:
        async with aiohttp.ClientSession() as session:
            clk = await alp_clock(session)
            market_open = bool(clk.get("is_open", False))
    except Exception:
        h = utc_hour()
        market_open = st.get("sess_start", 12) <= h <= st.get("sess_end", 20)

    # –Ω–∞–¥—Å–∏–ª–∞—î–º–æ –∑–≤—ñ—Ç —à–º–∞—Ç–∫–∞–º–∏
    for i in range(0, len(rep), 3500):
        await u.message.reply_text(rep[i:i+3500])

    # —è–∫—â–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ ‚Äî —Å—Ç–∞–≤–∏–º–æ –æ—Ä–¥–µ—Ä–∏
    if st.get("autotrade") and ALPACA_ENABLE:
        async with aiohttp.ClientSession() as session:
            res = await place_orders(st, session, u.effective_chat.id, market_open, picks_s, picks_c)
        if res:
            await u.message.reply_text("üìà –û—Ä–¥–µ—Ä–∏:\n" + "\n".join(res))
        else:
            await u.message.reply_text("üì≠ –û—Ä–¥–µ—Ä—ñ–≤ –Ω–µ –≤–∏—Å—Ç–∞–≤–ª–µ–Ω–æ (–Ω–µ –±—É–ª–æ –ø—Ä–∏–¥–∞—Ç–Ω–∏—Ö —Å–∏–≥–Ω–∞–ª—ñ–≤ –∞–±–æ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ OFF).")

# =========================
# Periodic scan task
# =========================

async def periodic_scan(app: Application):
    await asyncio.sleep(5)
    while True:
        try:
            for chat_id, st in list(STATE.items()):
                rep, picks_s, picks_c = await scan_all(st)
                st["last_scan_txt"] = rep
                # –∞–≤—Ç–æ—Ç—Ä–µ–π–¥ —É —Ñ–æ–Ω—ñ
                if st.get("autotrade") and ALPACA_ENABLE:
                    async with aiohttp.ClientSession() as session:
                        clk = await alp_clock(session)
                        market_open = bool(clk.get("is_open", False))
                        res = await place_orders(st, session, chat_id, market_open, picks_s, picks_c)
                        if res:
                            try:
                                await app.bot.send_message(chat_id, "ü§ñ –ê–≤—Ç–æ—Ç—Ä–µ–π–¥:\n" + "\n".join(res))
                            except Exception:
                                pass
        except Exception:
            pass
        await asyncio.sleep(max(10, SCAN_EVERY_SEC))

# =========================
# main
# =========================

async def main():
    if not TELEGRAM_TOKEN:
        print("Missing TELEGRAM_BOT_TOKEN"); return
    if not (ALPACA_API_KEY and ALPACA_API_SECRET):
        print("Missing Alpaca credentials"); return

    app = (
        ApplicationBuilder()
        .token(TELEGRAM_TOKEN)
        .rate_limiter(AIORateLimiter())
        .build()
    )

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", start_cmd))
    app.add_handler(CommandHandler("alp_on", alp_on_cmd))
    app.add_handler(CommandHandler("alp_off", alp_off_cmd))
    app.add_handler(CommandHandler("alp_status", alp_status_cmd))
    app.add_handler(CommandHandler("signals_alpaca", signals_cmd))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(CommandHandler("set_session", set_session_cmd))
    app.add_handler(CommandHandler("wl_off", wl_off_cmd))
    app.add_handler(CommandHandler("wl_on", wl_on_cmd))
    app.add_handler(CommandHandler("wl_clear", wl_clear_cmd))

    # –∑–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∞–≤—Ç–æ—Å–∫–∞–Ω—É
    app.job_queue.run_repeating(lambda *_: None, interval=3600)  # —Ç—Ä—é–∫, —â–æ–± job_queue —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞–≤—Å—è
    asyncio.create_task(periodic_scan(app))

    print("Bot started.")
    await app.initialize()
    await app.start()
    await app.updater.start_polling(drop_pending_updates=True)
    await app.updater.idle()
    await app.stop()
    await app.shutdown()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass
